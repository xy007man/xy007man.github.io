<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何观测Page Cache</title>
      <link href="/2024/08/31/%E8%A7%82%E6%B5%8BPage-Cache/"/>
      <url>/2024/08/31/%E8%A7%82%E6%B5%8BPage-Cache/</url>
      
        <content type="html"><![CDATA[<h2 id="一、什么是Page-Cache？">一、什么是Page Cache？</h2><p>为了提升对文件的读写效率，Linux 内核会以页大小（4KB）为单位，将文件划分为多数据块。当用户对文件中的某个数据块进行读写操作时，内核首先会申请一个内存页（称为 页缓存）与文件中的数据块进行绑定。如下图所示蓝色的地方就是Page Cache，很明显Page Cache是内核管理的内存，也就是说，它属于内核不属于用户。<br><img src="/2024/08/31/%E8%A7%82%E6%B5%8BPage-Cache/page_cache.png" alt="image-20210907004445908"></p><h2 id="二、如何观测Page-Cache">二、如何观测Page Cache</h2><pre><code class="language-shell">cat /proc/meminforoot@vultr:~# cat /proc/meminfo MemTotal:         979896 kBMemFree:           78116 kBMemAvailable:     451656 kBBuffers:           95416 kBCached:           374544 kBSwapCached:        18972 kBActive:           303408 kBInactive:         324400 kBActive(anon):      51252 kBInactive(anon):   118308 kBActive(file):     252156 kBInactive(file):   206092 kBUnevictable:       27476 kBMlocked:           27476 kBSwapTotal:       2457596 kBSwapFree:        2390652 kBZswap:                 0 kBZswapped:              0 kBDirty:              1764 kBWriteback:             0 kBAnonPages:        181836 kBMapped:            84972 kBShmem:              2808 kBKReclaimable:      71172 kB</code></pre><p>Active(file) + Inactive(file)即文件页，Active(anon)+Inactive(anon)即匿名页均属于Page Cacke</p><h2 id="三、文件页">三、文件页</h2><p>文件页，即与磁盘文件存在映射关系的内存页(有文件背景的页面)，例如进程代码段、文件的映射页等 ,他们有对应的硬盘文件，因此如果要交换，可以直接和硬盘对应的文件进行交换。内存紧张时，非dirty的文件页可以直接drop掉。Active(file) + Inactive(file)是与文件对应的内存页。</p><h2 id="四、匿名页">四、匿名页</h2><p>匿名页，没有文件背景的页面（即没有与磁盘文件存在任何映射关系的内存页面），如stack，heap，数据段，共享内存。SwapCached是打开Swap分区后，把Active(anon)+Inactive(anon)这2项的匿名页交换到磁盘，然后读取到内存后分配的内存。Shmem共享内存是指匿名共享映射的这种方式映射的内存，比如tmpfs（临时文件系统）</p><h2 id="五、为什么需要Page-Cache">五、为什么需要Page Cache</h2><p>减少I/O，提升应用的I/O速度</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小游戏桌球辅助器</title>
      <link href="/2021/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%A1%8C%E7%90%83%E8%BE%85%E5%8A%A9%E5%99%A8/"/>
      <url>/2021/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%A1%8C%E7%90%83%E8%BE%85%E5%8A%A9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>​最近在玩了一下微信小游戏中的桌球，游戏中自带的瞄准线太短了，就想找一个辅助器。在GitHub上搜索了半天没有发现特别好用的，GitHub上一般都是基于PC版的或者是需要用adb连接PC（晕，我玩个手机游戏还需要连着电脑？）。于是打算自己动手做一个。</p><h2 id="基本思路">基本思路</h2><ul><li><p>确定瞄准圆环的位置：将圆环的图片用抠图工具截取出来，使用opencv中的<code>matchTemplate</code>进行图像匹配（图中矩形）</p></li><li><p>确定瞄准线的坐标：使用深度优先算法，搜索瞄准圆环周边的白色像素坐标，然后取平均值，得到瞄准线的坐标（在图中两个圆环中间区域中搜索白色像素）</p></li><li><p>画出瞄准线：连接第一步确定的瞄准圆环圆心和第二步确定的瞄准线坐标画出瞄准线，另外需要注意的是我们画的是射线，需要通过这两点的相对位置，来确定射线的方向</p></li><li><p>在手机屏幕中显示出辅助线：利用android的的护眼模式的原理，创建一个透明的图层，覆盖在游戏上，绘制这个透明图层就能看到辅助线</p><p><img src="/2021/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%A1%8C%E7%90%83%E8%BE%85%E5%8A%A9%E5%99%A8/res.jpg" alt="res"></p></li></ul><h2 id="工程目录结构">工程目录结构</h2><ul><li>app主要负责屏幕截图、透明图层创建、绘制辅助线（本人不太了解android app开发，所以这部分代码只是勉强能用哈）</li><li>Billiards_SDK是JNI层，主要是进行瞄准圆环的匹配，确定辅助线坐标</li></ul><p><img src="/2021/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%A1%8C%E7%90%83%E8%BE%85%E5%8A%A9%E5%99%A8/image-20211017153332240.png" alt="image-20211017153332240"></p><hr><h2 id="辅助工具的使用">辅助工具的使用</h2><ul><li>使用android studio编译工程，将生成的apk文件push到手机中安装（第一次安装时需要悬浮权限、读取sdcard权限及录屏权限，依次允许就行）</li><li>将<code>Tball\other\circle.jpg</code>图像文件push到手机<code>/sdcard/Pictures</code>文件夹下，用于匹配瞄准环（我的手机屏幕分辨率是1080x2400，所以不同分辨率的手机需要自行截取圆环图像进行替换）</li><li>打开Tball apk后，分别点击<code>启动Service</code>、<code>初始化服务</code>，然后将apk切换到后台，之后正常启动游戏即可（有的手机可能会误杀后台进程造成辅助失效，需要手动设置一下电源管理）</li></ul><hr><h2 id="本地运行环境">本地运行环境</h2><ul><li>手机：荣耀V30 pro</li><li>android 版本：Android 10</li></ul><hr><h2 id="项目GitHub链接">项目GitHub链接</h2><ul><li><a href="https://github.com/xy007man/Tball">https://github.com/xy007man/Tball</a></li></ul><hr><h2 id="鸣谢（排名不分先后-）">鸣谢（排名不分先后~）</h2><ul><li><p>Android权限框架：<a href="https://github.com/getActivity/XXPermissions">https://github.com/getActivity/XXPermissions</a></p></li><li><p>MediaProjection 截屏、录屏Demo：<a href="https://github.com/jiashuaishuai/MediaProjectionDemo">https://github.com/jiashuaishuai/MediaProjectionDemo</a></p></li><li><p>自定义View之自动刷新View：<a href="https://blog.csdn.net/qq_16519957/article/details/88768025">https://blog.csdn.net/qq_16519957/article/details/88768025</a></p></li><li><p>Android如何实现全局的护眼模式：<a href="https://blog.csdn.net/weixin_42433094/article/details/119137569">https://blog.csdn.net/weixin_42433094/article/details/119137569</a></p></li><li><p>腾讯桌球助手：<a href="https://github.com/CSUFT-Running-Bug/billiard-assistant">https://github.com/CSUFT-Running-Bug/billiard-assistant</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JNI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 辅助器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一道面试题</title>
      <link href="/2021/09/24/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/09/24/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>​用C++实现一个String类，做成共享库，并通过googletest做单元测试，编写测试用例，要求使用CMakeLists组织整个工程。String类应包含一个成员变量char* m_data和以下函数：</p><ul><li><p>默认构造函数</p></li><li><p>构造函数，参数为const char*</p></li><li><p>复制构造</p></li><li><p>移动构造</p></li><li><p>析构</p></li><li><p>等号重载</p></li><li><p>+=重载，实现追加String类，即追加字符串，例 String a = “abc”, b= “def”; a += b; //a = “abcdef”</p></li><li><p>反转字符串</p></li><li><p>以某个字符分割字符串，返回List<string>，例String a = “abc def g”; 输出为{“abc”, “def”, “g”}</string></p></li></ul><p>​这个题目考察的是C++的基础能力和工程能力，做一下还蛮有意思的~~</p><hr><h2 id="目录结构">目录结构</h2><pre><code class="language-shell">└─string    │  CMakeLists.txt    │  readme.md    │    ├─3rd_party # gtest 依赖库和头文件    │  ├─gmock    │  │  │  gmock-actions.h    │  │  │  gmock-cardinalities.h    │  │  │  gmock-function-mocker.h    │  │  │  gmock-matchers.h    │  │  │  gmock-more-actions.h    │  │  │  gmock-more-matchers.h    │  │  │  gmock-nice-strict.h    │  │  │  gmock-spec-builders.h    │  │  │  gmock.h    │  │  │    │  │  └─internal    │  │      │  gmock-internal-utils.h    │  │      │  gmock-port.h    │  │      │  gmock-pp.h    │  │      │    │  │      └─custom    │  │              gmock-generated-actions.h    │  │              gmock-matchers.h    │  │              gmock-port.h    │  │              README.md    │  │    │  ├─gtest    │  │  │  gtest-death-test.h    │  │  │  gtest-matchers.h    │  │  │  gtest-message.h    │  │  │  gtest-param-test.h    │  │  │  gtest-printers.h    │  │  │  gtest-spi.h    │  │  │  gtest-test-part.h    │  │  │  gtest-typed-test.h    │  │  │  gtest.h    │  │  │  gtest_pred_impl.h    │  │  │  gtest_prod.h    │  │  │    │  │  └─internal    │  │      │  gtest-death-test-internal.h    │  │      │  gtest-filepath.h    │  │      │  gtest-internal.h    │  │      │  gtest-param-util.h    │  │      │  gtest-port-arch.h    │  │      │  gtest-port.h    │  │      │  gtest-string.h    │  │      │  gtest-type-util.h    │  │      │    │  │      └─custom    │  │              gtest-port.h    │  │              gtest-printers.h    │  │              gtest.h    │  │              README.md    │  │    │  └─lib    │          libgmock.a    │          libgmock_main.a    │          libgtest.a    │          libgtest_main.a    │    ├─app # 测试二进制存放路径    │      test    │    ├─build    ├─inc # String 共享库对外提供的头文件    │      String.h    │    ├─lib # String 共享库存放路径    │      libstring.so    │    ├─src # String 类的实现    │      CMakeLists.txt    │      String.cpp    │    └─test # gtest 测试目录            CMakeLists.txt            gtest.cpp            main.cpp</code></pre><hr><h2 id="工程编译方法">工程编译方法</h2><pre><code class="language-shell">cd build # 进入工程根目录下build目录cmake ..make../app/test # 执行app目录下可执行文件</code></pre><hr><h2 id="调试环境">调试环境</h2><ul><li>cmake version 3.16.3</li><li>Linux version 5.11.0-34-generic</li><li>gcc 9.3.0</li><li>ubuntu 20.04.1</li></ul><hr><h2 id="GitHub链接">GitHub链接</h2><ul><li><a href="https://github.com/xy007man/string">https://github.com/xy007man/string</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg学习：window环境搭建</title>
      <link href="/2021/09/07/ffmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/09/07/ffmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>​ffmpeg vs2019 环境搭建方法。</p><span id="more"></span><h2 id="将依赖的dll拷贝到工程根目录">将依赖的dll拷贝到工程根目录</h2><pre><code class="language-c">├─ffmpeg_lib_dll  // 此目录存放已经编译好的ffmpeg二进制文件和头文件│  ├─bin│  │  ├─win32 // ffmpeg dll│  │  └─win64│  ├─include // 头文件│  │  ├─libavcodec│  │  ├─libavdevice│  │  ├─libavfilter│  │  ├─libavformat│  │  ├─libavutil│  │  ├─libpostproc│  │  ├─libswresample│  │  └─libswscale│  ├─lib│  │  ├─win32 // ffmpeg lib│  │  └─win64│  └─src│      └─TestFFMpeg│          └─x64│              └─Debug│                  └─TestFFMpeg.tlog└─source    └─helloword // 把ffmpeg dll文件拷贝到此文件夹下        └─Debug            └─helloword.tlog</code></pre><p><img src="/2021/09/07/ffmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210907004445908.png" alt="image-20210907004445908"></p><hr><h2 id="配置附加目录（C-C-、链接器）">配置附加目录（C/C++、链接器）</h2><p><img src="/2021/09/07/ffmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210907003555086.png" alt="image-20210907003555086"></p><p><img src="/2021/09/07/ffmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210907003809294.png" alt="image-20210907003809294"></p><hr><h2 id="FFmpeg-第一个-Hello-Word">FFmpeg 第一个 Hello Word</h2><pre><code class="language-c++">#include &lt;stdio.h&gt;extern "C" {#include &lt;libavcodec/avcodec.h&gt;}#pragma comment(lib, "avcodec.lib")int main(){printf("%s\n", avcodec_configuration());return 0;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffmpeg学习：实现一个简单解码器</title>
      <link href="/2021/09/07/ffmpeg%E5%AD%A6%E4%B9%A0_MP4/"/>
      <url>/2021/09/07/ffmpeg%E5%AD%A6%E4%B9%A0_MP4/</url>
      
        <content type="html"><![CDATA[<p>​一个简单的解码MP4文件的ffmpeg解码器。</p><span id="more"></span><h2 id="FFmpeg-基本流程图">FFmpeg 基本流程图</h2><p><img src="/2021/09/07/ffmpeg%E5%AD%A6%E4%B9%A0_MP4/image-20210907232217743.png" alt="image-20210907232217743"></p><hr><h2 id="FFmpeg-层次结构">FFmpeg 层次结构</h2><p><img src="/2021/09/07/ffmpeg%E5%AD%A6%E4%B9%A0_MP4/image-20210907232400006.png" alt="image-20210907232400006"></p><hr><h2 id="简单的解码器实现代码">简单的解码器实现代码</h2><pre><code class="language-c++"></code></pre>]]></content>
      
      
      <categories>
          
          <category> ffmpeg </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector</title>
      <link href="/2021/09/05/vector/"/>
      <url>/2021/09/05/vector/</url>
      
        <content type="html"><![CDATA[<p>​记录几个 <code>vecotor</code> 易混淆的几个API用法。</p><span id="more"></span><h2 id="reserve-和-resize"><code>reserve</code> 和 <code>resize</code></h2><ul><li><code>reserve</code>增加了<code>vector</code>的<code>capacity</code>，但是它的<code>size</code>没有改变。<code>reserve</code>是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用<code>push_back()</code>/<code>insert()</code>函数。</li><li><code>resize</code>改变了<code>vector</code>的<code>capacity</code>同时也增加了它的<code>size</code>。<code>resize</code>是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用<code>operator[]</code>操作符，或者用迭代器来引用元素对象。此时再调用<code>push_back()</code>函数，是加在这个新的空间后面的。</li><li>如果<code>reserve(n)</code>函数的<code>n</code>的大小比<code>vector</code>原来的容量小。<code>capacity</code>没有变化。<code>size</code>也没有变：</li><li>如果<code>resize(n)</code>函数的<code>n</code>比<code>vector</code>原来的<code>size</code>小，结果是<code>size</code>减小到<code>n</code>，然后删除<code>n</code>之后的数据。</li></ul><pre><code class="language-c++">vector&lt;int&gt; myVec;myVec.reserve(100);     // 新元素还没有构造,                        // 此时不能用[]访问元素for (int i = 0; i &lt; 100; i++){     myVec.push_back(i); //新元素这时才构造}myVec.resize(102);      // 用元素的默认构造函数构造了两个新的元素myVec[100] = 1;         // 直接操作新元素myVec[101] = 2; </code></pre><hr><h2 id="clear"><code>clear</code></h2><ul><li><p><code>clear</code> 函数不会释放内存，即改变 <code>capacity</code>，只会将<code>size</code>改为0</p></li><li><p>用<code>swap</code>来帮助释放内存</p><pre><code class="language-c++">vector&lt;int&gt; nums; nums.push_back(1);nums.push_back(1);nums.push_back(2);nums.push_back(2); vector&lt;int&gt;().swap(nums); //或者 nums.swap(vector&lt;int&gt;())</code></pre></li></ul><hr><h2 id="emplace-back-和-push-back"><code>emplace_back</code> 和 <code>push_back</code></h2><ul><li><code>emplace_back</code>可以原地构造对象，然后加入到容器中，可以减少一次拷贝或构造</li><li><code>push_back</code>向容器中加入一个右值元素（临时对象）的时候，首先会调用<strong>构造函数</strong>构造这个临时对象，然后优先选择调用<strong>移动构造函数</strong>，如果没有才会调用<strong>拷贝构造函数</strong>临时对象放入容器中。原来的临时变量释放。这样造成的问题是临时变量申请的资源就浪费。</li><li><code>emplace_back</code>函数要比<code>push_back</code>函数要快一倍</li></ul><hr><h2 id="参考链接">参考链接</h2><ul><li><a href="https://blog.csdn.net/weixin_38314865/article/details/118068565">https://blog.csdn.net/weixin_38314865/article/details/118068565</a></li><li><a href="https://www.cnblogs.com/qlee/archive/2011/05/16/2048026.html">https://www.cnblogs.com/qlee/archive/2011/05/16/2048026.html</a></li><li><a href="https://blog.csdn.net/acoolgiser/article/details/81018296">https://blog.csdn.net/acoolgiser/article/details/81018296</a></li><li><a href="https://blog.csdn.net/hyl999/article/details/106235821">https://blog.csdn.net/hyl999/article/details/106235821</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vector </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>preempt_count</title>
      <link href="/2021/08/25/preempt_count/"/>
      <url>/2021/08/25/preempt_count/</url>
      
        <content type="html"><![CDATA[<p>​<code>preempt_count</code>本质上是一个per-CPU的32位变量，<code>preempt_count</code>代表的是该进程是否可以被抢占，<code>peermpt_count</code>等于0的时候当前进程就可以被抢占，当小于0存在bug，大于0说明当前进程不可以被抢占。具体每一位含义如下图所示。</p><span id="more"></span><p><img src="/2021/08/25/preempt_count/v2-ef0af5be9cedb02bead54a28b4d31a5c_720w.jpg" alt="preempt_count"></p><hr><h2 id="hardirq相关">hardirq相关</h2><p>​<code>preempt_count</code>中的第16到19个bit表示hardirq count，它记录了进入hardirq/top half的嵌套次数。irq_enter()用于标记hardirq的进入，此时hardirq count的值会加1。irq_exit()用于标记hardirq的退出，hardirq count的值会相应的减1。如果hardirq count的值为正数，说明现在正处于hardirq上下文中，代码中可借助**in_irq()**宏实现快速判断。注意这里的命名是"in_irq"而不是"in_hardirq"。</p><p>​hardirq count占据4个bits，理论上可以表示16层嵌套，但现在Linux系统并不支持hardirq的嵌套执行，所以实际使用的只有1个bit。</p><pre><code class="language-c">#define hardirq_count() (preempt_count() &amp; HARDIRQ_MASK)#define in_irq()  (hardirq_count())#define __irq_enter()\do {\account_irq_enter_time(current);\preempt_count_add(HARDIRQ_OFFSET);\trace_hardirq_enter();\} while (0)#define __irq_exit()\do {\trace_hardirq_exit();\account_irq_exit_time(current);\preempt_count_sub(HARDIRQ_OFFSET);\} while (0)int __handle_domain_irq(struct irq_domain *domain, unsigned int hwirq,bool lookup, struct pt_regs *regs){struct pt_regs *old_regs = set_irq_regs(regs);unsigned int irq = hwirq;int ret = 0;irq_enter(); // 进入中断hardirq++#ifdef CONFIG_HISI_BBirq_trace_hook(0, 0, hwirq);irq_register_hook(old_regs);#endif#ifdef CONFIG_IRQ_DOMAINif (lookup)irq = irq_find_mapping(domain, hwirq);#endif/* * Some hardware gives randomly wrong interrupts.  Rather * than crashing, do something sensible. */if (unlikely(!irq || irq &gt;= nr_irqs)) {ack_bad_irq(irq);ret = -EINVAL;} else {generic_handle_irq(irq);}#ifdef CONFIG_HISI_BBirq_trace_hook(1, 0, hwirq);#endifirq_exit(); // 退出中断hardirq--set_irq_regs(old_regs);return ret;}</code></pre><hr><h2 id="softirq相关">softirq相关</h2><p>​<code>preempt_count</code>中的第8到15个bit表示softirq count，它记录了进入softirq的嵌套次数，如果softirq count的值为正数，说明现在正处于softirq上下文中。由于softirq在单个CPU上是不会嵌套执行的，因此和hardirq count一样，实际只需要一个bit(bit 8)就可以了。但这里多出的7个bits并不是因为历史原因多出来的，而是另有他用。</p><pre><code class="language-c++">void irq_exit(void){#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLEDlocal_irq_disable();#elseWARN_ON_ONCE(!irqs_disabled());#endifaccount_irq_exit_time(current);preempt_count_sub(HARDIRQ_OFFSET);if (!in_interrupt() &amp;&amp; local_softirq_pending())invoke_softirq(); // 退出中断前，判断当前上下文不是软中断和硬中断，才会触发软中断(同一个cpu软中断不可嵌套)tick_irq_exit();rcu_irq_exit();trace_hardirq_exit(); /* must be last! */}asmlinkage __visible void __softirq_entry __do_softirq(void){unsigned long end = jiffies + MAX_SOFTIRQ_TIME;unsigned long old_flags = current-&gt;flags;int max_restart = MAX_SOFTIRQ_RESTART;struct softirq_action *h;bool in_hardirq;__u32 pending;int softirq_bit;/* * Mask out PF_MEMALLOC s current task context is borrowed for the * softirq. A softirq handled such as network RX might set PF_MEMALLOC * again if the socket is related to swap */current-&gt;flags &amp;= ~PF_MEMALLOC;pending = local_softirq_pending();account_irq_enter_time(current);__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET); // 进入软中断前softirq++in_hardirq = lockdep_softirq_start();restart:/* Reset the pending bitmask before enabling irqs */set_softirq_pending(0);local_irq_enable();h = softirq_vec;while ((softirq_bit = ffs(pending))) {unsigned int vec_nr;int prev_count;h += softirq_bit - 1;vec_nr = h - softirq_vec;prev_count = preempt_count();kstat_incr_softirqs_this_cpu(vec_nr);trace_softirq_entry(vec_nr);h-&gt;action(h);trace_softirq_exit(vec_nr);if (unlikely(prev_count != preempt_count())) {pr_err("huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\n",       vec_nr, softirq_to_name[vec_nr], h-&gt;action,       prev_count, preempt_count());preempt_count_set(prev_count);}h++;pending &gt;&gt;= softirq_bit;}rcu_bh_qs();local_irq_disable();pending = local_softirq_pending();if (pending) {if (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp;    --max_restart)goto restart;wakeup_softirqd();}lockdep_softirq_end(in_hardirq);account_irq_exit_time(current);__local_bh_enable(SOFTIRQ_OFFSET); // 退软中断前softirq--WARN_ON_ONCE(in_interrupt());current_restore_flags(old_flags, PF_MEMALLOC);}</code></pre><p>​这个"他用"就是表示在进程上下文中，为了防止进程被softirq所抢占，关闭/禁止softirq的次数，比如每使用一次local_bh_disable()，softirq count高7个bits(bit 9到bit 15)的值就会加1，使用local_bh_enable()则会让softirq count高7个bits的的值减1。</p><p>​代码中可借助**in_softirq()**宏快速判断当前是否在softirq上下文：</p><pre><code class="language-c">#define softirq_count()  (preempt_count() &amp; SOFTIRQ_MASK)#define in_softirq() (softirq_count())</code></pre><hr><h2 id="上下文">上下文</h2><p>​**in_interrupt()**的宏专门用来判断当前是否在中断上下文中</p><pre><code class="language-c">#define irq_count() (preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK | NMI_MASK)) #define in_interrupt()  (irq_count())</code></pre><p>与中断上下文相对应的就是俗称的进程上下文(process context)</p><pre><code class="language-c">#define in_task()  (!(preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_OFFSET | NMI_MASK)))</code></pre><p>​在中断上下文中，调度是关闭的，不会发生进程的切换，这属于一种隐式的禁止调度，而在代码中，也可以使用preempt_disable()来显示地关闭调度，关闭次数由第0到7个bits组成的preemption count(注意不是preempt count)来记录。每使用一次preempt_disable()，preemption count的值就会加1，使用preempt_enable()则会让preemption count的值减1。preemption count占8个bits，因此一共可以表示最多256层调度关闭的嵌套。</p><p>​处于中断上下文，或者显示地禁止了调度，preempt_count()的值都不为0，都不允许睡眠/调度的发生，这两种场景被统称为atomic上下文，可由**in_atomic()**宏给出判断。</p><pre><code class="language-go">#define in_atomic()(preempt_count() != 0)</code></pre><p>​中断上下文、进程上下文和atomic上下文的关系大概可以表示成这样：</p><p><img src="/2021/08/25/preempt_count/v2-3d4d6ecfcdec4be8c270dadfea0bd29a_720w.jpg" alt="中断上下文、进程上下文和atomic上下文的关系"></p><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/88883239">https://zhuanlan.zhihu.com/p/88883239</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1J64y1r7mK">linux内核开发第31讲：中断上下文、进程上下文环境的进入时机</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> preempt_count </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux nice 命令</title>
      <link href="/2021/08/19/%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/2021/08/19/%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>​Linux nice命令以更改过的优先序来执行程序，如果未指定程序，则会印出目前的排程优先序，内定的 adjustment 为 10，范围为 -20（最高优先序）到 19（最低优先序）。</p><p>使用权限：所有使用者。设定为负数需要管理者权限</p><span id="more"></span><h2 id="语法">语法</h2><pre><code class="language-shell">nice [-n adjustment] [-adjustment] [--adjustment=adjustment] [--help] [--version] [command [arg...]]</code></pre><h2 id="参数说明">参数说明</h2><ul><li><p>-n adjustment, -adjustment, --adjustment=adjustment 皆为将该原有优先序的增加 adjustment</p></li><li><p>–help 显示求助讯息</p></li><li><p>–version 显示版本资讯</p></li></ul><h2 id="实例">实例</h2><pre><code class="language-shell"># vi &amp; //后台运行[1] 15297# nice vi &amp; //设置默认优先级[2] 15298[1]+ Stopped         vi# nice -n 19 vi &amp; //设置优先级为19[3] 15299[2]+ Stopped         nice vi# nice -n -20 vi &amp; //设置优先级为 -20[4] 15300[3]+ Stopped         nice -n 19 vi# ps -l //显示进程F S  UID  PID PPID C PRI NI ADDR SZ WCHAN TTY     TIME CMD4 S   0 15278 15212 0 80  0 - 1208 wait  pts/2  00:00:00 bash0 T   0 15297 15278 0 80  0 - 2687 signal pts/2  00:00:00 vi0 T   0 15298 15278 0 90 10 - 2687 signal pts/2  00:00:00 vi0 T   0 15299 15278 1 99 19 - 2687 signal pts/2  00:00:00 vi4 T   0 15300 15278 3 60 -20 - 2687 signal pts/2  00:00:00 vi4 R   0 15301 15278 0 80  0 -  625 -   pts/2  00:00:00 ps[4]+ Stopped         nice -n -20 vi</code></pre><blockquote><p>注意：PRI表示进程当前的总优先级，值越小表示优先级越高，由进程默认的PRI加上NI得到，即PRI(new) = PRI(old) + NI。由上程序，进程默认的PRI是80，所以加上值为10的NI后，vi进程的PRI为90。 所以，需要注意的是，NI即niceness的值只是进程优先级的一部分，不能完全决定进程的优先级，但niceness值的绝对值越大，效果越显著。</p></blockquote><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://www.jianshu.com/p/fd3dec3cd393">Linux nice命令简要介绍</a></p></li><li><p><a href="https://www.runoob.com/linux/linux-comm-nice.html">Linux nice命令</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>视频协议中常见算法</title>
      <link href="/2021/08/17/%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
      <url>/2021/08/17/%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>​本文不推导具体公式，仅仅讲述一下在视频编码过程使用的算法。</p><p><img src="/2021/08/17/%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/20180416220957998.png" alt="编码流程图"></p><span id="more"></span><h2 id="运动估计（ME，Motion-Estimation）">运动估计（ME，Motion Estimation）</h2><ul><li>SAD、SATD、SSD、MSE、PSNR：视频编码失真测度，SAD和SATD常用在视频编码的模式选择</li><li>三步搜索、菱形搜索、六边形搜索：运动搜索算法，找到最佳匹配快</li><li>亚像素：根据相邻像素值计算得到，理论存在于实际像素之间的中间值，常用于提升运动搜索的精度</li></ul><h2 id="变换（T）">变换（T）</h2><ul><li>DST变换：H265帧内4x4模式亮度风量残差编码</li><li>DCT变换：H265除帧内4x4模式，其他残差编码均为DCT</li><li>Hadamard变换：用来计算SATD、编码H264直流分量，比DCT变换复杂度低</li></ul><h2 id="熵编码（Entropy-encode）">熵编码（Entropy encode）</h2><ul><li>CAVLC：实现简单，效率不如CABAC</li><li>CABAC：在不同的上下文环境中使用不同的概率模型来编码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核中的锁</title>
      <link href="/2021/08/16/%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/"/>
      <url>/2021/08/16/%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>​内核中自旋锁、信号量/mutex、读写锁/顺序锁、RCU介绍。</p><span id="more"></span><h2 id="自旋锁">自旋锁</h2><h3 id="为什么需要自旋锁">为什么需要自旋锁</h3><p>​很多时候我们并不能采用其他的锁，比如读写锁、互斥锁、信号量等。一方面这些锁会发生上下文切换，他的时间是不可预期的，对于一些简单的、极短的临界区完全是一种性能损耗；另一方面在中断上下文是不允许睡眠的，除了自旋锁以外的其他任何形式的锁都有可能导致睡眠或者进程切换，这是违背了中断的设计初衷，会发生不可预知的错误。基于两点，我们需要自旋锁，他是不可替代的。</p><h3 id="为什么自旋锁会禁止抢占">为什么自旋锁会禁止抢占</h3><p>​这一点其实很好理解，当一个 CPU 获取到一把自旋锁之后，开始执行临界区代码，此时假设他的时间片运转完毕，进程调度会主动触发调度将其调走，执行另一个线程/进程，结果恰巧了这个线程/进程也需要用到该自旋锁，而上一个线程/进程还在停留在临界区内未释放锁，导致本进程无法获取到锁而形成死锁，所以自旋锁为了规避此类情形的出现从而直接禁止对已经开始运行的临界区设置禁止抢占标志。</p><h3 id="为什么临界区禁止睡眠">为什么临界区禁止睡眠</h3><p>​如果自旋锁锁住以后进入睡眠，而此时又不能进行处理器抢占，内核的调取器无法调取其他进程获得该 CPU，从而导致该 CPU 被挂起；同时该进程也无法自唤醒且一直持有该自旋锁，进一步会导致其他使用该自旋锁的位置出现死锁。</p><h3 id="spin-lock-系列的分别">spin_lock 系列的分别</h3><p>​每一种锁出现都有自己的原因，spin_lock 系列的锁就是为了解决这一个又一个的问题才会新增的各种自旋锁变种，这也符合现代计算机代码设计逻辑，首先是解决有无问题之后再解决崩溃问题，最后才是性能问题，没有什么设计能够逃得出这样一个框架。</p><p>​spin_lock 出现的原因上文已经介绍过了，目标就是为了解决当前内核中，某些场景下快速访问临界区的问题而存在的，所以他禁止了调度器抢占，所以不存在任何其他的进程会抢占该 CPU 的情况。但是，现代计算机为了能够更快的响应各种外部消息，所以存在各种类型的中断，比如网卡中断的到来，就一定会打断正在执行的 CPU 的进程，哪怕是当前的程序被 spin_lock 给锁住了，假设当前的中断也需要访问该 spin_lock 锁，那么就会导致死锁发生，如图：</p><p><a href="https://i.loli.net/2018/09/20/5ba3446040187.png"><img src="/2021/08/16/%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/5ba3446040187.png" alt="img"></a></p><p>所以为了应对自旋锁同时出现在硬件中断和进程上下文的情况，所以应该在进程执行临界区代码段的自旋锁上锁之前，首先就应该关闭当前 CPU 的中断，这样无论你发生什么情况，一旦被锁上就不再会被任何的情况抢走 CPU，这就是 spin_lock_irq 出现的原因，当然，由于需要关闭中断，会导致系统的响应降低，而且还会执行更多的代码，可能会导致性能下降。</p><p>​那么 spin_lock_irqsave 又为何需要存在，之前说过每一种类型变种的出现都是为了解决实际问题，那么这个类型锁的出现也是为了解决一些实际问题。如图所示：</p><p><a href="https://i.loli.net/2018/09/20/5ba346d89fbd6.png"><img src="/2021/08/16/%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/5ba346d89fbd6.png" alt="img"></a></p><p>​从图中可以看出，当进程在执行第一个 spin_lock_irq(&amp;lock1) 时已经关闭了中断，然后继续获取第二个自旋锁spin_lock_irq(&amp;lock2)，当 lock2 解锁后且 lock1 未解锁前这一段区域处于一种硬件中断开启的状态，这段代码仍然处于 lock1 的临界区，如果此时硬件中断也需要申请 lock1 锁会导致死锁，这是因为 spin_unlock_irq 在解锁时一定会将本地 CPU 的中断打开，从而导致硬件中断可以重新强制抢占 CPU，所以最好的方式就是 lock2 在锁之前保存当前的中断状态，在解锁时恢复当前的中断状态，这也就是 spin_lock_irqsave 需要存在的原因。自然地，这是一种更为线程安全的方案，但是他会带来比前面几种更加多的性能损耗。</p><h3 id="什么场合使用什么类型的自旋锁">什么场合使用什么类型的自旋锁</h3><p>既然都已经了解了三种自旋锁的变种，那么什么情况下适合什么样的锁呢？</p><h4 id="spin-lock-使用场景">spin_lock 使用场景</h4><p>​首先如果整个临界区都只位于进程上下文或者工作队列中，那么只需要采用最为方便的 spin_lock 即可，因为他不会发生中断抢占锁的情况，哪怕中断抢占进程上下文也不会导致中断由于申请自旋锁而导致死锁。</p><p>​还有一种情况就是在硬件中断中可以考虑使用 spin_lock 即可，因为硬件中断不存在嵌套（未必一定是这样，与平台有关），所以只需要简单的上锁即可， 可以不需要关闭中断，保存堆栈等。</p><h4 id="spin-lock-irq-使用场景">spin_lock_irq 使用场景</h4><p>​这个锁的变种适合在进程上下文/软中断 + 硬件中断这样的组合中使用，taskset 也是属于软中断的一种，所以也归在此类。当然，这种类型的变种同样适合软中断/taskset + 进程上下文的组合，因为关闭了硬件中断，从源头就禁止执行软中断代码，不过，对于这种类型的中断最好的方式是使用 spin_lock_bh 的方式，因为他只锁定软中断代码执行，而不关闭硬件中断，这样性能损耗更小。</p><h4 id="spin-lock-irqsave-使用场景">spin_lock_irqsave 使用场景</h4><p>​这种类型的使用方式是最为安全以及便捷的，毕竟不需要考虑会不会发生死锁的问题（代码本身引入的死锁不在此类），但是他也是性能损耗最大的代码，能不使用尽量不适用，在高速设备上，自旋锁已然成为了一种降低性能的瓶颈。他最好只出现在在需要尝试 spin_lock 之前无法确定是否已经关闭中断的代码才使用，如果代码能够确定在执行锁之前中断一定是打开的，那么使用 spin_lock_irq 是更佳的选择。</p><h4 id="spin-lock-bh-使用场景">spin_lock_bh 使用场景</h4><p>​这种类型的变种是一种比 spin_lock_irq 更轻量的变种，只关闭中断底半部，其实就是关闭了软中断、Tasklet以及 Timer 等的一个抢占能力，如果开发者确定编写的代码临界区只存在软中断/Tasklet/Timer + 进程上下文这样的组合，则最好考虑使用 spin_lock_bh 这样的锁来禁止软中断进行抢占。还有就是软中断与软中断自我抢占临界区访问时，也需要使用 spin_lock_bh 以上的中断锁，因为有可能软中断在执行的过程中，自己被硬件中断打断，然后又执行到同样的代码，在别的 CPU 执行还好说，毕竟软中断可以在不同的 CPU 上执行同一个中断函数，但是假设不幸运行在同一个 CPU 上，则会导致死锁。Tasklet 由于在运行过程中钟只会运行一个实例，所以不存在死锁问题，Tasklet与 Tasklet 的锁竞争只需要使用 spin_lock 即可。</p><hr><h2 id="信号量和mutex">信号量和mutex</h2><p>​网上有一篇关于信号量和mutex的深入分析的介绍 ，最后作者有一段总结：</p><p>​具体可以参照：<a href="https://blog.csdn.net/weixin_32521765/article/details/116923700">https://blog.csdn.net/weixin_32521765/article/details/116923700</a></p><blockquote><p>​我们看到对mutex的优化其实遵循了代码优化的一般原则，即集中优化整个代码执行中出现的hot-spot(引申到高概率spot)。因为在实际使用当中，大多数情况 下，mutex_lock与mutex_unlock之间的代码都比较简短，使得获得锁的进程可以很快释放锁(因此，从性能优化的角度，这个也可以作为使 用mutex的一条一般原则)。如果系统中大部分拥有互斥锁的进程在mutex_lock与unlock之间执行时间比较长，那么相对于使用 semaphore，我相信使用mutex会使得系统性能降低：因为很大的概率，mutex都经过一段spin(虽然这段时间极短)之后最终还是进入 sleep，而semaphore则直接进入sleep，没有了spin的过程。</p></blockquote><hr><h2 id="读写锁和顺序锁">读写锁和顺序锁</h2><pre><code class="language-c">//定义读写锁rwlock_t rwlock;//初始化读写锁rwlock_init(&amp;rwlock);//读锁定read_lock(&amp;rwlock);//读锁定并关闭中断read_lock_irq(&amp;rwlock);//读解锁read_unlock(&amp;rwlock);//读解锁并恢复中断read_unlock_irqrestore(&amp;rwlock);//写锁定write_lock(&amp;rwlock);//写锁定并关闭中断write_lock_irq(&amp;rwlock);//写解锁write_unlock(&amp;rwlock);//写解锁并恢复中断write_unlock_irqrestore(&amp;rwlock);</code></pre><pre><code class="language-c">//定义顺序锁seqlock_t seq_lock;//初始化顺序锁seqlock_init(&amp;seq_lock);//写锁定write_seqlock(seqlock_t * sl);write_seqlock_irq(seqlock_t * sl);//写解锁write_sequnlock(seqlock_t * sl);write_sequnlock_irqrestore(seqlock_t * sl);//读申请unsigned int read_seqbegin(const seqlock_t * sl);//读有效判定int read_seqretry(const seqlock_t * sl, unsigned start);//demodo{    unsigned int seqnum=read_seqbegin(&amp;seqlock);    //读操作&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; .}while(read_seqretry(&amp;seqlock,seqnum));</code></pre><ul><li>读写锁和顺序锁相同点：读操作和读操作不互斥、读写互斥、写写互斥</li><li>读写锁和顺序锁不同点：读写锁读优先，即写操作会等所有读操作完成，才会进入；顺序锁写优先，demo中的 <code>do while</code>就是读者发现写操作修改数据，尝试再次读取。即如果当前有其他读操作，写操作也会执行。</li></ul><hr><h2 id="RCU">RCU</h2><p>​RCU在驱动中用的相对比较少，可以参考这篇文章：<a href="https://blog.csdn.net/xabc3000/article/details/15335131">https://blog.csdn.net/xabc3000/article/details/15335131</a></p><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://www.byteisland.com/%E8%87%AA%E6%97%8B%E9%94%81-spin_lock%E3%80%81-spin_lock_irq-%E4%BB%A5%E5%8F%8A-spin_lock_irqsave-%E7%9A%84%E5%8C%BA%E5%88%AB/">自旋锁 spin_lock、 spin_lock_irq 以及 spin_lock_irqsave 的区别</a></p></li><li><p><a href="https://blog.csdn.net/weixin_32521765/article/details/116923700">linux semaphore性能,深层次探讨mutex与semaphore之间的区别</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何Review代码</title>
      <link href="/2021/08/15/%E5%A6%82%E4%BD%95review%E4%BB%A3%E7%A0%81/"/>
      <url>/2021/08/15/%E5%A6%82%E4%BD%95review%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1>review 前准备</h1><ul><li>代码开发人员做好自review和自测试，杜绝代码中的低级错误</li><li>参加review的人员需要对代码业务有一定的了解，代码开发人员提前做好方案详细设计串讲</li><li>完成部分代码即可发起review，小步快跑，减少每次review代码量</li></ul><h1>review什么</h1><ul><li>专项review：参考《C/C++编程规范》、《C/C++安全编程规范》，这部分在开发人员自review时就应该做好</li><li>功能review：代码实现是否满足需求</li><li>可读性：圈复杂度、变量名命名合理、目录划分、函数代码行数、无冗余代码等等</li><li>可维护性/可扩展：数据结构/接口定义合理、兼容其他平台、提供测试接口、提供相关关键日志</li><li>性能review：算法实现是否最优，是否有执行效率低的代码等</li></ul><h1>写在最后</h1><p>​对于代码要做到<strong>谁开发，谁保护；谁污染，谁治理</strong>。对产品代码划分责任田，责任田主对代码的质量长期负责。之前和若干合作方合作过，合作方交付的代码质量堪忧，我认为其中一条就是合作方不对代码质量长期负责，合作方交付代码之后就没人管了。第一版代码的开发人员对代码的日后演进有至关重要的作用，如果第一版质量就很差，以后代码问题会像滚雪球一样问题越来越严重。一个Cisco来的专家讲过他们review代码方式：每个源码文件都有相关的review人员，这些人员都是当初开发这段代码的人员或者维护过这段代码的人员，无论他们目前在公司做什么工作，一旦有人改了这段代码，这些人都会收到相关的邮件review通知。他就曾经半夜收到某大领导的电话，这个人多年前曾维护过这段代码，给他提了好多有效的review意见。</p><p>​最后的最后，代码的质量决定的根本因素还是开发代码人员，一个程序员的基本素养是啥？自己埋下的坑自己填，自己的BUG自己能解。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核同步机制：自旋锁</title>
      <link href="/2021/08/08/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E8%87%AA%E6%97%8B%E9%94%81/"/>
      <url>/2021/08/08/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E8%87%AA%E6%97%8B%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="自旋锁系列函数">自旋锁系列函数</h2><table><thead><tr><th>函数</th><th>功能说明</th></tr></thead><tbody><tr><td>void spin_lock(spinlock_t *lock)</td><td>进程和进程之间同步</td></tr><tr><td>void spin_lock_bh(spinlock_t *lock)</td><td>和本地软中断之间同步</td></tr><tr><td>void spin_lock_irq(spinlock_t *lock)</td><td>和本地硬件中断之间同步</td></tr><tr><td>void spin_lock_irqsave(lock, flags)</td><td>和本地硬件中断之间同步并保存本地中断状态</td></tr><tr><td>int spin_trylock(spinlock_t *lock)</td><td>尝试获取锁，如果成功返回非0值，否则返回0值</td></tr></tbody></table><hr><h2 id="自旋锁特点">自旋锁特点</h2><ul><li><code>spinlock</code>是一种死等的锁机制</li><li>临界区执行时间短且不可睡眠，可以在中断上下文中使用。由于<code>spinlock</code>死等的这种特性，如果临界区执行时间长，那么不断在临界区死等的执行单元会浪费CPU资源</li></ul><hr><h2 id="自旋锁的公平性">自旋锁的公平性</h2><pre><code class="language-c">typedef struct spinlock {union {struct raw_spinlock rlock;#ifdef CONFIG_DEBUG_LOCK_ALLOC# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))struct {u8 __padding[LOCK_PADSIZE];struct lockdep_map dep_map;};#endif};} spinlock_t;typedef struct raw_spinlock {arch_spinlock_t raw_lock;#ifdef CONFIG_GENERIC_LOCKBREAKunsigned int break_lock;#endif#ifdef CONFIG_DEBUG_SPINLOCKunsigned int magic, owner_cpu;void *owner;#endif#ifdef CONFIG_DEBUG_LOCK_ALLOCstruct lockdep_map dep_map;#endif} raw_spinlock_t;typedef struct {union {u32 slock;struct __raw_tickets {#ifdef __ARMEB__u16 next;u16 owner;#elseu16 owner; // owner表示持有这个数字的thread可以获取自旋锁u16 next; // next表示如果后续再有thread请求获取这个自旋锁，就给他分配这个数字#endif} tickets;};} arch_spinlock_t;</code></pre><ul><li><p>数据结构：spinlock_t --&gt; raw_spinlock_t --&gt; arch_spinlock_t</p></li><li><p>自旋锁公平调度实现方式</p><ul><li>刚开始owner = next = 0</li><li>第一个thread获取spinlock，可以获取成功，此时owner = 0， next = 0</li><li>第二个thread获取spinlock，如果第一个thread还没有释放spinlock，则next++，next变为1</li><li>第三个thread获取spinlock，如果第一个thread还没有释放spinlock，则next++，next变为2</li><li>此时第一个thread释放spinlock，则执行owner++，owner = 1</li><li>虽然此时第二个thread和第三个thread都在等待spinlock，但是因为第二个thread的next=owner，所以第二个thread可以获取到spinlock，第三个thread则继续等待，这样保证了spinlock的唤醒机制是先到先唤醒，后到后唤醒，保证了公平性。</li></ul><pre><code class="language-c">static inline void arch_spin_lock(arch_spinlock_t *lock){unsigned long tmp;u32 newval;arch_spinlock_t lockval;prefetchw(&amp;lock-&gt;slock);    // 下面这段汇编翻译成C语言就是    /*    lockval = lock-&gt;slock;    newval = lockval + (1 &lt;&lt; TICKET_SHIFT) &lt;=等价于=&gt; newval.ticket.next = lockval.tickets.next++    lockval = newval    */__asm__ __volatile__("1:ldrex%0, [%3]\n""add%1, %0, %4\n""strex%2, %1, [%3]\n""teq%2, #0\n""bne1b": "=&amp;r" (lockval), "=&amp;r" (newval), "=&amp;r" (tmp): "r" (&amp;lock-&gt;slock), "I" (1 &lt;&lt; TICKET_SHIFT): "cc");while (lockval.tickets.next != lockval.tickets.owner) { // 死等循环，直到 owner == nextwfe(); // cpu进入低功耗状态lockval.tickets.owner = ACCESS_ONCE(lock-&gt;tickets.owner);}smp_mb();}</code></pre></li></ul><hr><h2 id="参考链接">参考链接</h2><ul><li><p>自旋锁Spinlock <a href="https://blog.csdn.net/longwang155069/article/details/52055876">https://blog.csdn.net/longwang155069/article/details/52055876</a></p></li><li><p>linux内核开发第18讲：spinlock在SMP下的源码实现 <a href="https://www.bilibili.com/video/BV1Yh411R7YC">https://www.bilibili.com/video/BV1Yh411R7YC</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自旋锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H.265/HEVC环路滤波技术</title>
      <link href="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/"/>
      <url>/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/</url>
      
        <content type="html"><![CDATA[<p>​<code>H.265/HEVC</code> 仍然采用基于块的混合编码框架，方块效应、振铃效应、颜色偏差以及图像模糊等失真效应仍存在。为降低这类失真对视频的影响，<code>H.265/HEVC</code>采用环路滤波技术，包括去方块滤波（Deblocking Filter）和像素自适应补偿（Sample Adaptive Offset）两个模块。去方块滤波用于降低方块效应，像素自适应补偿用于改善振铃效应。如图所示可以看出，经过滤波的重构像素才能作为后续编码像素参考使用。环路滤波处理后的重建图像更有利于参考，进一步减小后续编码像素的预测残差，可有效地提高视频的主观质量。</p><span id="more"></span><p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2.png" alt="环路滤波"></p><hr><h2 id="块效应">块效应</h2><p>块效应是指图像中编码块编解不连续，如图所示，压缩重建图像有明显的方块效应，严重影响主观质量。</p><p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/421096-20160518153202404-1659522803.gif" alt="img"></p><hr><h3 id="块效应产生原因">块效应产生原因</h3><ul><li>各个块变换量化编码过程独立，相当于对各个块使用了不同参数的滤波器分别滤波，因此各块引入的量化误差大小及其分布特征相互独立，导致相邻编解的不连续。</li><li>运动补偿预测过程中，相邻块的预测值可能来自不同图像的不同位置，这样就导致预测残差信号在块的边界产生数值不连续。</li><li>时域预测技术使得参考图像中窜在的边界不连续可能会传递到后续编码图像</li></ul><hr><h3 id="去方块滤波技术">去方块滤波技术</h3><p>​滤波的主要工作就是判断块边界是否需要进行滤波，并且决定采用的滤波强度（大白话就是对边界多少个像素进行平滑，即取均值）。过强的滤波会造成图像细节不必要的平滑，而缺乏滤波则会造成块效应。</p><ul><li>确定滤波边界</li><li>计算边界强度</li><li>对亮度分量进行滤波开关决策、滤波强弱选择</li><li>滤波</li></ul><hr><h2 id="振铃效应">振铃效应</h2><p>所谓“振铃”，就是指输出图像的灰度剧烈变化处产生的震荡，就好像钟被敲击后产生的空气震荡。</p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/振铃效应.png" alt="振铃效应" style="zoom:200%;"><hr><h3 id="振铃效应产生原因">振铃效应产生原因</h3><ul><li><p><code>H.265/HEVC</code> 采用基于块的<code>DCT</code>变换，并在频域对变换系数进行量化。对于强边缘，由于高频系数的量化失真，解码后会在边缘周围产生波纹现象，造成此现象的根本原因是高频信息丢失。如图所示，实线中的高频信息丢失后变成了虚线（实线表示原始像素值，虚线表示重构像素值）。可以看出重构像素值在边缘两侧上下波动。</p><p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/%E6%8C%AF%E9%93%83%E6%95%88%E5%BA%942.png" alt="振铃效应"></p></li></ul><hr><h3 id="像素自适应补偿">像素自适应补偿</h3><p>像素值原来是平坦区，因为量化丢弃了部分高频分量，形成了某些像素值得偏移，使得原来相对平坦的像素值关系或多或少地形成局部峰点、谷点或拐点。那么，像素自适应补偿就是人为地对这些飘逸的像素加上一个适当的相反的补偿量，以抵消编码造成的偏移。</p><p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/3596589-2c845f743b4e20a3.png" alt="img"></p><hr><h2 id="参考链接">参考链接</h2><ul><li><p>5.H.265/HEVC—— 环路后处理 <a href="https://www.jianshu.com/p/1de7e26001f4">https://www.jianshu.com/p/1de7e26001f4</a></p></li><li><p>新一代高效视频编码H.265HEVC原理、标准与实现 [万帅，杨付正 编著] 2014年版</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 视频 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 去块滤波 </tag>
            
            <tag> 像素自适应补偿 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集线器、交换机、路由器</title>
      <link href="/2021/08/06/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"/>
      <url>/2021/08/06/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h2 id="早期网络设备集线器HUB">早期网络设备集线器HUB</h2><h3 id="集线器特点">集线器特点</h3><ul><li>集线器工作于物理层，所有端口同属一个碰撞域和广播域，每个端口仅对数据信号进行放大和转发</li><li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用 <code>CSMA/CD</code> 协议处理总线竞争访问</li><li>由于工作在数据链路层的交换机比集线器性能更高，故集线器已经逐渐被淘汰</li></ul><h3 id="CSMA-CD-和-CSMA-CA-协议"><code>CSMA/CD</code> 和 <code>CSMA/CA</code> 协议</h3><ul><li><code>CSMA/CD</code> 是有线局域网解决总线竞争访问的协议，目前由于交换器的使用这个协议逐渐也被淘汰</li><li><code>CSMA/CA</code> 是无线局域网解决竞争访问的协议，目前仍广泛使用</li></ul><hr><h2 id="交换机SWITCH">交换机SWITCH</h2><h3 id="交换机特点">交换机特点</h3><ul><li><p>交换机工作于数据链路层（也包括物理层），根据MAC地址对帧进行转发</p></li><li><p>交换机的每个接口都是独立的碰撞域，交换机只隔离碰撞域不隔离广播域</p><p><img src="/2021/08/06/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/d058ccbf6c81800aab934511b13533fa828b47bf" alt="交换机"></p></li></ul><h3 id="交换表">交换表</h3><ul><li><p>交换机有一张交换表，表中记录的是<strong>帧的目的MAC地址所对应的接口号</strong>，然后通过该接口转发数据帧</p></li><li><p>刚上电时交换机中的交换表是空的，此时交换机会将从某个接口收到的数据流向除该接口之外的所有接口发送出去（泛洪），随着网络中各主机间的通信，以太网交换机通过<strong>自学习算法</strong>逐渐建立起帧交换表</p></li><li><p>扩展阅读：MAC泛洪攻击和防御 <a href="https://blog.csdn.net/pygain/article/details/52059238">https://blog.csdn.net/pygain/article/details/52059238</a></p></li></ul><h3 id="交换机生成树协议-STP">交换机生成树协议 <code>STP</code></h3><ul><li>为提高网络的可靠性，网络中添加了冗余链路，这些冗余链路可能会出现环路，网络环路会带来以下几个问题：<ul><li>广播风暴：大量消耗网络资源，使网络无法转发其他数据帧</li><li>主机收到重复的广播帧</li><li>交换机的真交换表震荡（漂移）</li></ul></li><li>以太网交换机使用生成树协议<code>STP</code>，可以在增加冗余链路提高网络可靠性的同时又避免网络环路<ul><li>不论交换机之间采用何种物理连接，交换机都能自动计算并构建一个逻辑上没有环路的网络</li><li>最终的生成网络确保可以连通整个网络</li><li>首次接入或者物理网络发生变化，交换机会进行生成树的重新计算</li></ul></li></ul><hr><h2 id="路由器">路由器</h2><h3 id="路由器特点">路由器特点</h3><ul><li><p>路由器工作在网络层，根据IP地址对报文进行转发</p></li><li><p>交换机不能分割广播域，路由可以</p></li><li><p>路由器实现了不同网络之间的数据转发，交换机实现了特定网络内的数据交换</p></li></ul><h3 id="路由表和转发表">路由表和转发表</h3><ul><li>路由表包含目的网络到下一跳的映射</li><li>路由表需要对网络拓扑变化的计算最优化</li><li>转发表是由路由表得出的</li><li>转发表的结构应该使查找过程最优化</li></ul><h3 id="路由选择协议">路由选择协议</h3><ul><li>静态路由选择：人工配置</li><li>动态路由选择：根据路由协议自动获取路由信息<ul><li>内部网关协议<ul><li>路由信息协议<code>RIP</code></li><li>内部网关路由协议<code>IGRP</code></li><li>增强型内部网关路由协议<code>EIGRP</code></li><li>开放式最短路径优先<code>OSPF</code></li><li>中间系统到中间系统<code>IS-IS</code></li></ul></li><li>外部网关协议<ul><li>边界网关协议<code>BGP</code></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络设备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径Dijkstra算法</title>
      <link href="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"/>
      <url>/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Dijkstra算法简介">Dijkstra算法简介</h2><p>​Dijkstra算法算是<strong>贪心思想</strong>实现的，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。</p><hr><h2 id="算法核心">算法核心</h2><ul><li><p>选择一个节点标记成已经遍历</p><ul><li><p>选择从起点到其他节点路径最短的节点，如图所示起始点0到1、2、3的距离分别为5、2、6，当前不可达的4记作无穷大，则下一个被选择的节点就是2</p><p><img src="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/1627869608-ZNeWka-image.png" alt="图1"></p></li></ul></li><li><p>在遍历过程中更新起始点到其他节点的最短距离</p><ul><li><p>从起始点0到1的距离为5，按照步骤一选取下个节点2后，0-&gt;2-&gt;1距离比0-&gt;1距离要短（这里已经间接说明为什么第一步要选择2的原因了），需要将距离由5更新为3</p><p><img src="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/1627869851-VtwdFS-image.png" alt="图2"></p></li></ul></li><li><p>Dijkstra算法终止条件：遍历完毕所有可达的节点</p><p><img src="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/1627869914-XQvKqz-image.png" alt="图3"></p></li></ul><hr><h2 id="算法实现">算法实现</h2><p>LeetCode题目<a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a>，这里我直接用优先队列来实现节点的选择，更能说明问题。</p><pre><code class="language-c++">class Solution {public:    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k)     {        vector&lt;int&gt; dis(n + 1, -1);         dis[k] = 0;        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; // 元素递增        pq.push(make_pair(0, k)); // first:距离, second:节点编号        while (!pq.empty()) {            pair&lt;int, int&gt; dst = pq.top();            pq.pop(); // 选取优先队列中第一个节点，即从起点到其他节点路径最短的节点            if (dst.first &gt; dis[dst.second]) { // 当前达到dst的权值比记录的还要大，则不可能是最短路径                continue;            }            for (int i = 0; i &lt; times.size(); i++) {                if (times[i][0] != dst.second) {                    continue;                }                // 遍历以dst为起点的路径                int v = times[i][1];                int w = dst.first + times[i][2];                if (dis[v] == -1 || dis[v] &gt; w) {                    dis[v] = w; // 更新距离                    pq.push(make_pair(w, v));                }            }        }        int ans = 0;        for (int i = 1; i &lt;= n; i++) {            if (dis[i] == - 1) {                return -1;            }            ans = max(ans, dis[i]);        }         return ans;    }};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo + GitHub 搭建个人博客</title>
      <link href="/2021/08/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/08/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo-GitHub-搭建个人博客">Hexo + GitHub 搭建个人博客</h2><ul><li><p>安装<code>nodeJs</code>，版本号选择为 <code>v12.14.0</code>，最好选择免安装版本<code>node-v12.14.0-win-x64.zip</code>解压后即可使用</p><p>NodeJs下载地址：<a href="https://nodejs.org/dist/v12.14.0/">https://nodejs.org/dist/v12.14.0/</a>  (注意：免安装版本需要自行添加环境变量)</p></li><li><p>配置<code>npm</code> （<code>nodeJs</code>默认自带<code>npm</code>命令，此步骤可选择，参考链接：<a href="https://www.cnblogs.com/dalyday/p/10664287.html%EF%BC%89">https://www.cnblogs.com/dalyday/p/10664287.html）</a></p><ul><li><p>将<code>npm</code>的默认下载目录从<code>c</code>盘移动到<code>D</code>盘</p><pre><code class="language-shell">npm config set prefix "D:\tool\nodeJs\node_global"npm config set cache "D:\tool\nodeJs\node_cache"</code></pre></li><li><p>配置镜像源，提升速度</p><pre><code class="language-shell">npm config set registry=http://registry.npm.taobao.org</code></pre></li><li><p>查看配置是否成功</p><pre><code class="language-shell">npm config list=====================如下都是回显信息，也可以直接修改C:\Users\xy\.npmrc文件配置===============; cli configsmetrics-registry = "https://registry.npm.taobao.org/"scope = ""user-agent = "npm/6.13.4 node/v12.14.0 win32 x64"; userconfig C:\Users\xy\.npmrccache = "D:\\tool\\nodeJs\\node_cache"prefix = "D:\\tool\\nodeJs\\node_global"registry = "https://registry.npm.taobao.org/"; node bin location = D:\tool\nodeJs\node.exe; cwd = D:\tool; HOME = C:\Users\xy; "npm config ls -l" to show all defaults.</code></pre></li><li><p>由于<code>nodeJs</code>自带的<code>npm</code>不是最新的版本，可以自行升级<code>npm</code>模块</p><pre><code class="language-shell">npm install npm -gnpm -v # 查看npm版本号</code></pre></li><li><p>因为之前修改了<code>npm</code>默认的目录，所以在环境变量<code>PATH</code>中添加<code>D:\tool\nodeJs\node_global</code></p></li></ul></li><li><p>安装 <code>hexo</code></p><pre><code class="language-shell">npm install -g hexo # nodeJs默认自带npm命令</code></pre></li><li><p>选择一个空文件夹作为Blog的根目录，执行初始化，可以自定义下载其他主题</p><pre><code class="language-shell">hexo initgit clone git@github.com:Haojen/hexo-theme-Claudia.git themes/claudia # 下载claudia主题</code></pre></li><li><p>设置<code>NPM</code>淘宝源，安装 <code>CNPM</code></p><pre><code class="language-shell">npm i cnpm -g --registry=http://registry.npm.taobao.org</code></pre></li><li><p>进入<code>Blog</code>根路径安装包</p><pre><code class="language-shell">#必要cnpm install hexo-renderer-pug --savecnpm install hexo-renderer-sass --save cnpm install hexo-generator-search --save cnpm install hexo-deployer-git --save#选择性安装# 如果需要添加订阅功能cnpm install hexo-generator-feed --save # 流程图功能cnpm install hexo-filter-flowchart --save   # Emojicnpm install hexo-filter-github-emojis --save  # 搜索功能cnpm install hexo-generator-search --save   # 数学公式cnpm install hexo-renderer-mathjax --save</code></pre></li><li><p>其他推荐安装包 (可选步骤)</p><ul><li>Hexo中插入<code>mermaid diagrams</code> (<a href="https://blog.csdn.net/Olivia_Vang/article/details/92987859">https://blog.csdn.net/Olivia_Vang/article/details/92987859</a>)</li><li>Hexo中插入本地图片 (<a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a>)</li></ul></li><li><p>配置根目录下的 <code>GitHub</code>项目路径</p><pre><code class="language-shell">deploy:  type: git  repository: git@github.com:xy007man/xy007man.github.io.git  branch: master</code></pre></li></ul><hr><h2 id="参考链接">参考链接</h2><ul><li><p><code>Hexo + GitHub</code> 搭建个人博客：<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p></li><li><p><code>Claudia</code> 主题介绍：<a href="https://github.com/Haojen/hexo-theme-Claudia/blob/master/README-CN.md">https://github.com/Haojen/hexo-theme-Claudia/blob/master/README-CN.md</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核同步机制：mutex锁</title>
      <link href="/2021/07/24/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E9%94%81/"/>
      <url>/2021/07/24/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Mutex锁的使用">Mutex锁的使用</h2><table><thead><tr><th>函数定义</th><th>功能说明</th></tr></thead><tbody><tr><td>mutex_lock(struct mutex *lock)</td><td>加锁，如果不可用，则睡眠（UNINTERRUPTIBLE）</td></tr><tr><td>mutex_lock_interruptible(struct mutex *lock);</td><td>加锁，如果不可用，则睡眠（TASK_INTERRUPTIBLE）</td></tr><tr><td>mutex_unlock(struct mutex *lock)</td><td>解锁</td></tr><tr><td>mutex_trylock(struct mutex *lock)</td><td>试图获取指定的 mutex，或得到返回1，否则返回 0</td></tr><tr><td>mutex_is_locked(struct mutex *lock)</td><td>如果 mutex 被占用返回1，否则返回 0</td></tr></tbody></table><hr><h2 id="Mutex锁和其他锁的区别">Mutex锁和其他锁的区别</h2><ul><li><code>mutex</code> 一种睡眠锁，其行为和 count 为 1 的信号量类似，但是不同于信号量，<code>mutex</code>需要谁拿的锁谁来释放锁</li><li>不同于自旋锁，mutex临界区允许睡眠</li><li>不同于自旋锁，mutex在拿锁时若锁被别人持有，会根据锁的持有者是否正在运行来决定是乐观自旋或是睡眠等待</li></ul><hr><h2 id="Mutex锁的实现">Mutex锁的实现</h2><ul><li><a href="https://blog.csdn.net/zhoutaopower/article/details/86627438">https://blog.csdn.net/zhoutaopower/article/details/86627438</a></li><li><a href="https://zhuanlan.zhihu.com/p/390107537">https://zhuanlan.zhihu.com/p/390107537</a></li></ul><p>​以上两篇文章介绍的比较好，可以参考看一下，总结一下<code>mutex</code>的特点</p><ul><li><code>mutex</code> 由于性能原因并不是绝对公平调度的，允许偷锁的情况，但是为了相对公平引入了<code>handoff</code>机制，让被偷锁的进程在下次一定可以获取锁。</li><li><code>mutex</code> 锁有自旋锁和信号量的特点，即当持有锁的进程处于执行状态时，等待锁的进程会关闭抢占进行自旋；若持有锁的进程处于睡眠状态时，等待锁的进程也会进行休眠，和信号量的表现一致。</li><li>信号量和<code>mutex</code>锁优选<code>mutex</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mutex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内核同步机制：信号量</title>
      <link href="/2021/07/17/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2021/07/17/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="信号量的使用">信号量的使用</h2><pre><code class="language-c">struct semaphore {raw_spinlock_tlock;unsigned intcount;struct list_headwait_list;};void sema_init(struct semaphore *sem, int val);void down(struct semaphore *sem);int down_interruptible(struct semaphore *sem); // 在睡眠期间可以被信号打断返回void up(struct semaphore *sem)</code></pre><hr><h2 id="源码分析">源码分析</h2><pre><code class="language-c">void down(struct semaphore *sem){unsigned long flags;raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);if (likely(sem-&gt;count &gt; 0)) // 对应sema_init中的第二个参数val，如果当前大于0，当前进程可以进入临界区执行sem-&gt;count--;else__down(sem); // 否则将将当前进程阻塞住raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);}// down 最终会调用到 __down_commonstatic inline int __sched __down_common(struct semaphore *sem, long state,long timeout){struct semaphore_waiter waiter;list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list); // 将当前进程加入等待链表中waiter.task = current; // current 代表当前进程的结构体waiter.up = false;for (;;) {if (signal_pending_state(state, current)) // 如果当前进程有信号处理，则返回-EINTRgoto interrupted;if (unlikely(timeout &lt;= 0))goto timed_out;__set_current_state(state); // 设置当前进程状态(TASK_INTERRUPTIBLE/TASK_UNINTERRUPTIBLE)raw_spin_unlock_irq(&amp;sem-&gt;lock);timeout = schedule_timeout(timeout); // 主动退出调度，进入此函数后进程已经成功阻塞住了，等待被唤醒raw_spin_lock_irq(&amp;sem-&gt;lock); if (waiter.up)return 0;} timed_out:list_del(&amp;waiter.list);return -ETIME; interrupted:list_del(&amp;waiter.list);return -EINTR;}void up(struct semaphore *sem){unsigned long flags;raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);if (likely(list_empty(&amp;sem-&gt;wait_list))) // 当前没有任何进程阻塞在该信号量上sem-&gt;count++;else__up(sem);raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);}static noinline void __sched __up(struct semaphore *sem){struct semaphore_waiter *waiter = list_first_entry(&amp;sem-&gt;wait_list,struct semaphore_waiter, list); // 获取第一个阻塞在此信号量上的进程list_del(&amp;waiter-&gt;list);waiter-&gt;up = true;wake_up_process(waiter-&gt;task); // 唤醒进程}</code></pre><h2 id="总结">总结</h2><p>​可以看到Linux内核中信号量的使用和实现都是十分简洁的。可以看出内核中用一条链表实现了阻塞在信号量上多个进程的公平调度，不过从内核中的实现来看貌似这并不是最优的实现，因为临界区代码往往都比较短小，但是如果进程获取不到信号量就会直接睡眠下去，这可能会造成进程频繁的睡眠唤醒。下一节会分析一下内核中 <code>mutex</code> 的实现。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信号量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程银弹</title>
      <link href="/2021/07/10/%E7%BC%96%E7%A8%8B%E9%93%B6%E5%BC%B9/"/>
      <url>/2021/07/10/%E7%BC%96%E7%A8%8B%E9%93%B6%E5%BC%B9/</url>
      
        <content type="html"><![CDATA[<h1>小白</h1><p>记得在大一刚接触编程时，经常陷入语法的陷阱，把大部分精力放在了学习语法上，经常因为知道了语言上的一些奇技淫巧而沾沾自喜。大一实验课设计一个的图书管理系统，代码删删改改，磕磕碰碰最后勉强跑通，感觉费了好多脑细胞。时常听到编程语言只是工具，好的代码是给人看的，好的代码需要好的设计。之后学习了软件工程、接触了23种设计模式，但是仍然懵懵懂懂，经常在想编程到底有没有银弹。</p><span id="more"></span><hr><h1>工作</h1><p>工作之后，部门潇潇洒洒规定了百八十条的编程规范让新员工记住。印象比较深的就是一个函数不要超过50行。其实在刚开始我也没觉的有啥坏处，按照规定来就行了。之后就出现了各种牛鬼蛇神的代码，许多代码明明放在一个函数逻辑比较通顺，为了符合编程规范必须拆分成2个甚至3个函数。</p><hr><h1>思考</h1><p>一个函数超过50行就是烂代码吗？显然不是这样。我也写了几年代码，自己有一点感触。当你要设计一个类或者函数时，第一要<strong>先明确</strong>函数的功能，明确好入参和出参**。新手时常陷入其中细节的逻辑中，缺啥参数返回头在去增加，修改来修改去，最终成型的代码，参数可能有5、6个，临时变量7、8个，函数行数膨胀到2~3百行。第二在写具体逻辑的时候，<strong>如果发现你的脑细胞不够用的，一定要意识到你应该</strong>再封装一个函数了**。你自己写的代码你应该最清楚业务逻辑，但是你自己写的时候都费劲，如果这样的业务代码交给别人去review或者维护那将是一个灾难。一般一个函数代码行数不应该超过一屏半，最好不要超过150行，但是代码行不应该做为判断代码好坏的绝对条件。</p><p>最后回到主题编程有银弹吗？我认为是没有的，不能靠条条框框的编程规范去让程序员写出更好的代码。靠编程规范约束的开发人员不会是一个好的开发人员，他已经被这些条条框框约束住了，缺失了创造力。大家最不愿意做的是啥？就是写设计文档，说白了就是不愿意思考，如果模块的接口定义好了，其实剩下的就是搬砖了。不否定编程规范对新手的积极作用，但是作为一位老鸟应该明白其中的门道。希望有一天我也能像卖油翁那样说一句：“无他，唯手熟尔”。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS基本原理简析</title>
      <link href="/2021/07/03/HTTPS/"/>
      <url>/2021/07/03/HTTPS/</url>
      
        <content type="html"><![CDATA[<h2 id="基础">基础</h2><ul><li><p>对称加密算法</p><p>对称加密算法的特点是加密密钥和解密密钥是同一把密钥K，且加解密速度快，典型的对称加密算法有DES、AES等</p><p><img src="/2021/07/03/HTTPS/548912-20160303105320549-487055351.png" alt="对称加密算法加密流程和解密流程"></p></li><li><p>非对称加密算法</p><p>​非对称加密算法的特点是加密密钥K1和解密密钥K2是不一样的，他们是一对可互为加解密的密钥，一个可以公开，叫公钥；一个自己保留，不能让其他人知道，叫私钥。这样就能比较好的解决信息传递的安全性，相对来说加解密速度较慢，典型的非对称加密算法有RSA、DSA等。</p><p><img src="/2021/07/03/HTTPS/548912-20160303111011190-1826727713.png" alt="非对称加密算法加密流程和解密流程"></p></li></ul><hr><h2 id="非对称加密的两大应用">非对称加密的两大应用</h2><ul><li><p>加密通信：公钥加密，私钥解密</p></li><li><p>数字签名：私钥加密，公钥解密</p><ul><li><p>发送方（甲方）签名过程：使用单向哈希算法对明文生成摘要，用私钥将摘要加密</p><p><img src="/2021/07/03/HTTPS/548912-20160303111013487-1921207550.png" alt="摘要算法及数字签名过程"></p></li><li><p>接收方（乙方）校验过程：接受方把接收到的发送方的明文用单向哈希函数取得摘要值与发送方的公钥解密发送方的数字签名而得到的摘要值进行比较，如果一样说明信息完整，未受篡改，如果不一样说明受到篡改。</p><p><img src="/2021/07/03/HTTPS/548912-20160303111014549-473199446.png" alt="检验数据完整性过程"></p></li></ul></li></ul><hr><h2 id="HTTPS的工作方式">HTTPS的工作方式</h2><p>​<code>HTTPS</code> 实际采用的是混合加密的方式，即通过<strong>非对称加密的方式传递对称加密的密钥，对称加密的方式传递主体数据</strong>，通过<strong>检查证书是不是由可以信赖的机构颁发的，确认证书有效和此证书是此网站的，即检查公钥的合法性</strong>。</p><p><img src="/2021/07/03/HTTPS/548912-20160303111014549-47319944.png" alt="HTTPS工作方式"></p><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://www.cnblogs.com/gordon0918/p/5237717.html">https://www.cnblogs.com/gordon0918/p/5237717.html</a></p></li><li><p><a href="https://www.cnblogs.com/wang-yaz/p/10604403.html">https://www.cnblogs.com/wang-yaz/p/10604403.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> https </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字节序/比特序</title>
      <link href="/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/"/>
      <url>/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="大端序-小端序">大端序/小端序</h2><p>​字节序即字节的存储顺序，如果数据都是单字节的，那怎么存储无所谓了，但是对于多字节数据，比如int，double等，就要考虑存储的顺序了。字节序是硬件层面的东西，通常只和你使用的处理器架构有关，而和编程语言无关。字节序分为大端序和小端序。</p><ul><li><p><strong>大端序</strong>：<strong>将高序字节存储在起始地址</strong>，一个占有4个字节类型的数据0x00112233在内存中如下分布：</p><p><img src="/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/19d498caac5304a2faedd537c5544d87.png" alt="大端模式"></p></li><li><p><strong>小端序</strong>：<strong>将低序字节存储在起始地址</strong>，数据0x00112233在内存中如下分布：</p><p><img src="/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/664881c6233ab0ed63cddc96db08afbc.png" alt="小端模式"></p><hr><h2 id="比特序-位域">比特序/位域</h2><p>​位域的写入顺序和当前系统字节序有关：先定义的位域在大端环境从最高bit位(<code>MSB</code>)开始分配。如果为小端环境则先定义的位域从最低bit位（<code>LSB</code>）开始分配。(CPU操作内存还是以字节为单位的)</p><pre><code class="language-c">struct bitfield{    uint8_t a:1;    uint8_t b:2;    uint8_t c:3;    uint8_t d:2;}bf;bf.a = 1;bf.b = 2;bf.c = 3;bf.d = 3;</code></pre></li><li><p>大端系统：<code>struct bitfield bf</code> 在内存中如下分布：</p><p><img src="/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/5dad1350789a2397a4830e8c4d4d322a.png" alt="MSB"></p></li><li><p>小端系统：<code>struct bitfield bf</code> 在内存中如下分布：</p></li></ul><p><img src="/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/4c5e9f8058a75efa50022165f273e476.png" alt="LSB"></p><p>​比特的发送、接收顺序对CPU、软件都是不可见的，（对诸如PHY的serdes(串行器和解串器)以及网卡写总线的硬件设计是非常重要的）因为我们的网卡会给我们处理这种转换，在发送的时候按照小端序发送比特位，<strong>在接收的时候网卡会把接收到的比特序转换成主机的比特序</strong>，下面是一个小端机器发送一个int整型给一个大端机器的示意图：</p><p>​<img src="/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/20171222210949014" alt="bit网络发送"></p><p>​因为不同的平台的比特序是不同的，但是我们定义的位域需要根据平台的大小端进行转换，以iphdr为例：</p><pre><code class="language-c">struct iphdr {#if defined(__LITTLE_ENDIAN_BITFIELD)        __u8    ihl:4,                version:4;#elif defined (__BIG_ENDIAN_BITFIELD)        __u8    version:4,                ihl:4;#else#error  "Please fix &lt;asm/byteorder.h&gt;"#endif        __u8    tos;        __u16   tot_len;        __u16   id;        __u16   frag_off;        __u8    ttl;        __u8    protocol;        __u16   check;        __u32   saddr;        __u32   daddr;        /*The options start here. */};</code></pre><hr><h2 id="网络序-主机序">网络序/主机序</h2><ul><li>网络序：采用大端的排序方式</li><li>主机序：不同的CPU有不同的字节序类型这些字节序是指整数在内存中保存的顺序，CPU上运行不同的操作系统，字节序也是不同的</li></ul><table><thead><tr><th>处理器</th><th>操作系统</th><th>字节排序</th></tr></thead><tbody><tr><td>Alpha</td><td>全部</td><td>Little endian</td></tr><tr><td>HP-PA</td><td>NT</td><td>Little endian</td></tr><tr><td>HP-PA</td><td>UNIX</td><td>Big endian</td></tr><tr><td>Intelx86</td><td>全部</td><td>Little endian</td></tr><tr><td>Motorola680x</td><td>全部</td><td>Big endian</td></tr><tr><td>MIPS</td><td>NT</td><td>Little endian</td></tr><tr><td>MIPS</td><td>UNIX</td><td>Big endian</td></tr><tr><td>PowerPC</td><td>NT</td><td>Little endian</td></tr><tr><td>PowerPC</td><td>非NT</td><td>Big endian</td></tr><tr><td>RS/6000</td><td>UNIX</td><td>Big endian</td></tr><tr><td>SPARC</td><td>UNIX</td><td>Big endian</td></tr><tr><td>IXP1200 ARM核心</td><td>全部</td><td>Little endian</td></tr></tbody></table><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://blog.csdn.net/firefly_2002/article/details/8034046">https://blog.csdn.net/firefly_2002/article/details/8034046</a></p></li><li><p><a href="https://blog.csdn.net/qq_34907757/article/details/117670413">https://blog.csdn.net/qq_34907757/article/details/117670413</a></p></li><li><p><a href="https://blog.csdn.net/godleading/article/details/78876639">https://blog.csdn.net/godleading/article/details/78876639</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字节序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux字符设备驱动与杂项设备驱动</title>
      <link href="/2021/06/27/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8_%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
      <url>/2021/06/27/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8_%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="字符设备驱动">字符设备驱动</h2><pre class="mermaid">graph LRA[字符设备驱动框架]--&gt;B1[驱动初始化]B1[驱动初始化]--&gt;C1[分配设备号]C1[分配设备号]--&gt;D1[静态分配设备号]D1[静态分配设备号]--&gt;E(register_chrdev_region)C1[分配设备号]--&gt;D2[动态分配设备号]D2[动态分配设备号]--&gt;F(alloc_chrdev_region)C1[分配设备号]--&gt;D3[操作设备号dev_t]D3[操作设备号dev_t]--&gt;Z1(MAJOR提取主设备号)D3[操作设备号dev_t]--&gt;Z2(MINOR提取主设备号)D3[操作设备号dev_t]--&gt;Z3(MKDRV将主次设备号合成dev_t)D3[操作设备号dev_t]--&gt;Z4(cat /proc/device/xxx查看设备号)B1[驱动初始化]--&gt;C2[初始化cdev]C2[初始化cdev]--&gt;G(cdev_init)B1[驱动初始化]--&gt;C3[注册cdev]C3[注册cdev]--&gt;H(cdev_add)A[字符设备驱动框架]--&gt;B2[构建file_operations]B2[构建file_operations]--&gt;J1(open)B2[构建file_operations]--&gt;J2(read)J2(read)--&gt;K(copy_to_user)B2[构建file_operations]--&gt;J3(write)J3(write)--&gt;L(copy_from_user)B2[构建file_operations]--&gt;J4(ioctl)J4(ioctl)--&gt;M(copy_from_user/copy_to_user)B2[构建file_operations]--&gt;J5(close)A[字符设备驱动框架]--&gt;B3[生成设备节点]B3[生成设备节点]--&gt;N1[手动生成设备节点]N1[手动生成设备节点]--&gt;O(mknod命令)B3[生成设备节点]--&gt;N2[自动生成设备节点]N2[自动生成设备节点]--&gt;M1(class_create:在/sys/class/目录下创建一个class)N2[自动生成设备节点]--&gt;M2(device_create:在/dev/目录下创建一个device)A[字符设备驱动框架]--&gt;B4[驱动卸载]B4[驱动卸载]--&gt;P1[释放设备号]P1[释放设备号]--&gt;Q(unregister_chrdev_region)B4[驱动卸载]--&gt;P2[卸载cdev]P2[卸载cdev]--&gt;R(cdev_del)B4[驱动卸载]--&gt;P3[卸载设备]P3[卸载设备]--&gt;T(device_destory)</pre><hr><h2 id="杂项设备驱动">杂项设备驱动</h2><pre class="mermaid">graph LRA[杂项设备驱动框架]--&gt;B1[注册杂项设备]B1[注册杂项设备]--&gt;C(misc_register)A[杂项设备驱动框架]--&gt;B2[构建杂项设备结构体]B2[构建杂项设备结构体]--&gt;D(struct miscdevice:对次设备号/设备节点名称/file_operations初始化)A[杂项设备驱动框架]--&gt;B3[构建file_operations]B3[构建file_operations]--&gt;J1(open)B3[构建file_operations]--&gt;J2(read)J2(read)--&gt;K(copy_to_user)B3[构建file_operations]--&gt;J3(write)J3(write)--&gt;L(copy_from_user)B3[构建file_operations]--&gt;J4(ioctl)J4(ioctl)--&gt;M(copy_from_user/copy_to_user)B3[构建file_operations]--&gt;J5(close)A[杂项设备驱动框架]--&gt;B4[卸载杂项设备]B4[卸载杂项设备]--&gt;E(misc_deregister)</pre><hr><h2 id="应用层打开节点">应用层打开节点</h2><pre class="mermaid">graph LRA[应用程序]--&gt;B1[open]B1--&gt;C[file_operations]A[应用程序]--&gt;B2[read]B2--&gt;C[file_operations]A[应用程序]--&gt;B3[write]B3--&gt;C[file_operations]A[应用程序]--&gt;B4[ioctl]B4--&gt;C[file_operations]A[应用程序]--&gt;B5[close]B5--&gt;C[file_operations]C--&gt;D1[内核注册的open]C--&gt;D2[内核注册的read]C--&gt;D3[内核注册的write]C--&gt;D4[内核注册的ioctl]C--&gt;D5[内核注册的close]D1--&gt;E[操作硬件]D2--&gt;E[操作硬件]D3--&gt;E[操作硬件]D4--&gt;E[操作硬件]D5--&gt;E[操作硬件]</pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 驱动 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人机对弈</title>
      <link href="/2021/06/26/%E4%BA%BA%E6%9C%BA%E5%AF%B9%E5%BC%88/"/>
      <url>/2021/06/26/%E4%BA%BA%E6%9C%BA%E5%AF%B9%E5%BC%88/</url>
      
        <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>​小时候在FC上玩过象棋游戏，印象最深的就是那个老头，每次走棋贼慢同时棋力也特高。一直想了解下人机对弈的算法，看了几篇文章后，发现基本的套路都是一样的，自己写了一个小时候玩的<code>两口吃一口</code>的小游戏。</p><img src="/2021/06/26/%E4%BA%BA%E6%9C%BA%E5%AF%B9%E5%BC%88/FC象棋.jpg" alt="FC象棋" style="zoom:50%;"><hr><h2 id="棋类AI基本步骤-以下都是基于两口吃一口这个小游戏">棋类AI基本步骤(以下都是基于<code>两口吃一口</code>这个小游戏)</h2><ul><li><p><strong>局面生成</strong>：棋子种类、开局位置</p><pre><code class="language-c++">// 5x5 棋盘，黑方和白方初始时都有5颗棋子/*  0 1 2 3 4 ┌─────────┐0│○─○─○─○─○│1│├─┼─┼─┼─┤│2│├─┼─┼─┼─┤│3│├─┼─┼─┼─┤│4│●─●─●─●─●│ └─────────┘ */std::string GenBoard(int row, int col, int colNum, int rowNum, std::map&lt;std::pair&lt;int, int&gt;, int&gt; board){std::string str;auto it = board.find(std::make_pair(row, col));if (it != board.end()) {if (it-&gt;second == WHITE) {return "○";}if (it-&gt;second == BLACK) {return "●";}}if (row == 0 &amp;&amp; col == 0) {str = "┌";}else if (row == 0 &amp;&amp; col == colNum - 1) {str = "┐";}else if (row == rowNum - 1 &amp;&amp; col == 0) {str = "└";}else if (row == rowNum - 1 &amp;&amp; col == colNum - 1) {str = "┘";}else if (row == 0) {str = "┬";}else if (col == colNum - 1) {str = "┤";}else if (col == 0) {str = "├";}else if (row == rowNum - 1) {str = "┴";}else {str = "┼";}return str;}// 棋盘绘制void DrawBoard(){std::string posCol;std::string topBorderLine;std::string bottomBorderLine;posCol += "  ";for (int i = 0; i &lt; g_colNum; i++) {posCol += std::to_string(i) + " ";}GenBorderLine(topBorderLine, bottomBorderLine, g_colNum);std::cout &lt;&lt; posCol &lt;&lt; std::endl;std::cout &lt;&lt; topBorderLine &lt;&lt; std::endl;for (int rowIdx = 0; rowIdx &lt; g_rowNum; rowIdx++) {std::cout &lt;&lt; std::to_string(rowIdx) &lt;&lt; "│";for (int colIdx = 0; colIdx &lt; g_colNum; colIdx++) {std::cout &lt;&lt; GenBoard(rowIdx, colIdx, g_rowNum, g_colNum, g_board);if (colIdx != g_colNum - 1) {std::cout &lt;&lt; "─";}}std::cout &lt;&lt; "│" &lt;&lt; std::endl;}std::cout &lt;&lt; bottomBorderLine &lt;&lt; std::endl;}</code></pre></li><li><p><strong>走法生成</strong>：走棋规则、吃子规则、胜利规则</p><pre><code class="language-c++">// 上下左右不超出棋盘并且目标位置没有棋子void GenMoveWays(int player, std::vector&lt;std::tuple&lt;int, int, int, int&gt;&gt;&amp; ways){int direct[4][2] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };for (auto &amp;i : g_board) {if (i.second != player) {continue;}for (int k = 0; k &lt; 4; k++) {int nextRow = i.first.first + direct[k][0];int nextCol = i.first.second + direct[k][1];if (CheckPostion(nextRow, nextCol)) {continue;}auto nextIt = g_board.find(std::make_pair(nextRow, nextCol));if (nextIt != g_board.end()) {continue;}ways.push_back(std::make_tuple(i.first.first, i.first.second, nextRow, nextCol));}}}/* 一行或者一列两个连续己方棋子可以吃对方一个棋子 _○○●_：OK ○○●__：OK __○○●：OK ○○●_●：这种情况不能吃子 ○○○●_：这种情况不能吃子 _○○○●：这种情况不能吃子 _●○○●：这种情况不能吃子 ●○○●_：这种情况不能吃子*/int GetPieceNumByDirect(int row, int col, int direct[2]){int pieceNum = 0;if (direct[0] != 0 &amp;&amp; direct[1] != 0) {std::cout &lt;&lt; "错误的方向" &lt;&lt; std::endl;assert(0);return 0;}if (direct[0] != 0) {for (int i = 0; i &lt; g_rowNum; i++) {auto it = g_board.find(std::make_pair(i, col));if (it != g_board.end()) {pieceNum++;}}return pieceNum;}for (int i = 0; i &lt; g_colNum; i++) {auto it = g_board.find(std::make_pair(row, i));if (it != g_board.end()) {pieceNum++;}}return pieceNum;}// 当前走棋方棋子数量小于2，则为失败（连续两个棋子才能吃对方一个棋子）bool IsCurrentPlayLose(){return GetPieceNum(g_currentPlayer) &lt; 2;}</code></pre></li><li><p><strong>局面评估</strong>：这部分其实是大多棋类AI的关键，别看我写的局面评估只有一个语句</p><pre><code class="language-c++">// 己方棋子越多，对自己越有利int EvaluatePosition(){return GetPieceNum(WHITE) - GetPieceNum(BLACK);}</code></pre></li><li><p><strong>局面搜索</strong>：搜索算法要和评估函数结合，通过好的剪枝算法会大大提高AI的智慧，我这里就是一个简单极大极小值深度优先搜索</p><pre><code class="language-c++">int GenOneStep(int fromRow, int fromCol, int toRow, int toCol, std::vector&lt;std::pair&lt;int, int&gt;&gt; &amp;eats){std::set&lt;std::tuple&lt;int, int, int, int&gt;&gt; ways;if (!IsVaildPiece(fromRow, fromCol, toRow, toCol, g_currentPlayer)) {return -1;}// 走一步棋DeletePiece(fromRow, fromCol, g_currentPlayer);AddPiece(toRow, toCol, g_currentPlayer);// 吃子EatPiece(toRow, toCol, g_currentPlayer, eats);// 交换走棋方ChangePlayer();//DrawBoard();return 0;}void UndoOneStep(int fromRow, int fromCol, int toRow, int toCol, std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; eats){// 还原被吃掉的对方棋子for (auto&amp; i : eats) {AddPiece(i.first, i.second, g_currentPlayer); // 当前走棋方为对方}eats.clear();// 交换走棋方ChangePlayer();// 撤销上一步棋DeletePiece(toRow, toCol, g_currentPlayer);AddPiece(fromRow, fromCol, g_currentPlayer);}int Search(int depth, int&amp; fromRow, int&amp; fromCol, int &amp;toRow, int &amp;toCol){int bestValue;int value;if (depth == 0) {return EvaluatePosition();}if (g_currentPlayer == BLACK) {bestValue = INFINITY_VALUE;  // bestValue越小对黑方越有利}else {bestValue = -INFINITY_VALUE; // bestValue越大对白方越有利}std::vector&lt;std::tuple&lt;int, int, int, int&gt;&gt; ways;std::vector&lt;std::pair&lt;int, int&gt;&gt; eats;GenMoveWays(g_currentPlayer, ways);for (auto&amp; i : ways) {if (GenOneStep(std::get&lt;0&gt;(i), std::get&lt;1&gt;(i), std::get&lt;2&gt;(i), std::get&lt;3&gt;(i), eats)) {continue;}value = Search(depth - 1, fromRow, fromCol, toRow, toCol);UndoOneStep(std::get&lt;0&gt;(i), std::get&lt;1&gt;(i), std::get&lt;2&gt;(i), std::get&lt;3&gt;(i), eats);if (g_currentPlayer == BLACK) {if (value &lt; bestValue) {bestValue = value;if (depth == MAX_SEARCH_DEPTH) {fromRow = std::get&lt;0&gt;(i);fromCol = std::get&lt;1&gt;(i);toRow = std::get&lt;2&gt;(i);toCol = std::get&lt;3&gt;(i);}}}else {if (value &gt; bestValue) {bestValue = value;if (depth == MAX_SEARCH_DEPTH) {fromRow = std::get&lt;0&gt;(i);fromCol = std::get&lt;1&gt;(i);toRow = std::get&lt;2&gt;(i);toCol = std::get&lt;3&gt;(i);}}}}// 当前方已经无棋可走了if (g_currentPlayer == BLACK &amp;&amp; bestValue == INFINITY_VALUE) {// 黑方value越小越好，即搜索深度越深到达无路可走越好return INFINITY_VALUE - (MAX_SEARCH_DEPTH - depth);}if (g_currentPlayer == WHITE &amp;&amp; bestValue == -INFINITY_VALUE) {return (MAX_SEARCH_DEPTH - depth) - INFINITY_VALUE;}return bestValue;}void ComputerOneStep(){int fromRow;int fromCol;int toRow; int toCol;std::vector&lt;std::pair&lt;int, int&gt;&gt; eats;Search(MAX_SEARCH_DEPTH, fromRow, fromCol, toRow, toCol);GenOneStep(fromRow, fromCol, toRow, toCol, eats);}</code></pre></li></ul><hr><h2 id="项目链接">项目链接</h2><p><a href="https://github.com/xy007man/2KouChiYiKou">https://github.com/xy007man/2KouChiYiKou</a></p><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://www.zhihu.com/question/34816738">https://www.zhihu.com/question/34816738</a></p></li><li><p><a href="https://www.xqbase.com/computer.htm">https://www.xqbase.com/computer.htm</a></p></li><li><p><a href="https://www.zhihu.com/question/29472711/answer/45436565">https://www.zhihu.com/question/29472711/answer/45436565</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 极大极小值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>踩内存</title>
      <link href="/2021/06/22/%E8%B8%A9%E5%86%85%E5%AD%98/"/>
      <url>/2021/06/22/%E8%B8%A9%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>​对于C/C++程序员来说，踩内存问题是最难分析定位的，往往问题的源头都比较隐蔽，让人很难排查出问题的根源所在。</p><span id="more"></span><hr><h2 id="原因">原因</h2><ul><li><p>内存越界</p><ol><li><code>memset/memcpy/memmove</code> 等内存操作函数操作越界，使用这些函数时尽可能用 <code>memset_s/memcpy_s/memmove_s</code> 等安全函数替代。</li><li>内存越界的问题有个显著的特点，被踩的内存是连续的，遇到这种情况首先怀疑在被踩内存前面申请的内存的操作是否越界。</li></ol></li><li><p>数组越界/操作字符串越界</p><p>数组越界访问往往是最常见的踩内存原因，对于数组访问一定要先判断下标是否越界</p></li><li><p>野指针</p><ol><li>对于全局的变量在释放内存后一定要置为NULL，防止出现野指针</li><li>警惕浅拷贝潜在的野指针风险。浅拷贝只是拷贝了它在栈中存储的指针，它们指向的都是同一个堆内存地址，所以浅拷贝在某些情况会造成改变数据后导致别的另一份数据也同步被改变的情况；而深拷贝是直接将堆内存中存储的数据直接复制一份，不会有浅拷贝互相影响的问题。</li><li>某些时候查看 <code>coredump</code> 现场发现程序访问的地址非常小，首先怀疑空指针。因为结构体的基地址是0，程序在访问结构体成员时会进行若干字节的偏移，所以最终挂死的现场的地址非常小。</li></ol></li><li><p>多线程场景下，全局资源未作加锁保护</p><p>这种情况可能更加复杂，需要对代码进行深度检视</p></li></ul><hr><h2 id="常用定位手段">常用定位手段</h2><ul><li><p>使用系统提供的函数修改内存为只读属性，发生踩内存时程序会直接崩溃，查看相关 <code>coredump</code> 文件进行分析定位</p><ol><li><p>用户态进程：<code>mprotect</code></p><pre><code class="language-c">#include &lt;unistd.h&gt;#include &lt;sys/mmap.h&gt;int mprotect(const void *start, size_t len, int prot);</code></pre><p>函数使用方法参考：<a href="https://www.cnblogs.com/ims-/p/13222243.html">https://www.cnblogs.com/ims-/p/13222243.html</a></p></li><li><p>内核：<code>set_mem_rw</code></p><pre><code class="language-c">#include &lt;linux/kallsyms.h&gt;int set_mem_rw(unsigned long ,int)set_mem_rw = (void *)kallsyms_lookup_name("set_memory_rw"); // 这个函数内核并未导出，不能直接调用</code></pre></li></ol></li><li><p>valgrind 工具分析</p><p>valgrind是一个强大的内存管理工具，常用来检测内存泄漏和内存的非法使用</p><p>具体使用方法参考：<a href="https://blog.csdn.net/weixin_29666341/article/details/116637397">https://blog.csdn.net/weixin_29666341/article/details/116637397</a></p></li><li><p><code>GCC</code> 栈保护机制 <code>stack-protector</code></p><p>程序执行栈内存被踩，程序崩溃的位置是不确定的，为了使崩溃的地点更加接近问题点，可以在编译时加入相关编译选项</p><p>具体使用方法参考：<a href="https://www.cnblogs.com/arnoldlu/p/11630979.html">https://www.cnblogs.com/arnoldlu/p/11630979.html</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 问题定位 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向代理和正向代理</title>
      <link href="/2021/06/21/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2021/06/21/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="代理">代理</h2><p>​代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。刚开始的时候，代理多数是帮助内网client访问外网server用的后来出现了反向代理，"反向"这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内。</p><hr><h2 id="正向代理">正向代理</h2><p>​正向代理类似一个跳板机，代理访问外部资源比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了。</p><p><img src="/2021/06/21/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="正向代理"></p><p><strong>正向代理的用途：</strong></p><ul><li><p>访问原来无法访问的资源，如google</p></li><li><p>可以做缓存，加速访问资源</p></li><li><p>对客户端访问授权，上网进行认证</p></li><li><p>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p></li></ul><hr><h2 id="反向代理">反向代理</h2><p>​反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。反向代理一般就是指Nginx，是在主服务器之外加一层代理服务器，用户的请求会发送到代理服务器上，由代理服务器请求真正的服务器，获得到结果后再将结果返回给用户。</p><p><img src="/2021/06/21/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="反向代理"></p><p><strong>反向代理的作用：</strong></p><ul><li><p>保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网</p></li><li><p>负载均衡，通过反向代理服务器来优化网站的负载</p></li></ul><hr><h2 id="CDN">CDN</h2><p>​CDN是内容分发网络（Content Delivery Network）。是为了解决用户请求响应过慢的问题。比如用户在黑龙江，服务器在海南，用户请求的速度可能受距离、带宽的影响。CDN将几台机器分发在全国各地，用户发出的请求会选择就近的CDN服务器进行处理。CDN简单的来说就是存储一些静态文件的一台或多台服务器，通过复制，缓存主服务器等方式，将文件保存其中。</p><p><img src="/2021/06/21/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/CDN.jpg" alt="CDN"></p><p><strong>CDN作用：</strong></p><ul><li>CDN作用和反向代理相同，一方面加快用户访问速度，另一方面也减轻了后端服务器的负载压力</li></ul><p><strong>CDN和反向代理的区别：</strong></p><ul><li>CDN和反向代理的基本原理都是缓存，区别在于CDN部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据。</li><li>反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。</li></ul><hr><h2 id="应用">应用</h2><p><strong>正向代理</strong>：</p><ul><li><p>许多科学上网的软件如SS、SSR、v2ray原理上都是正向代理，可以参考：</p><p><a href="https://github.com/xiaoming2028/FreePAC">v2ray搭建教程</a><br><a href="https://github.com/233boy/v2ray">v2ray安装脚本</a></p></li></ul><p><strong>反向代理/CDN：</strong></p><ul><li><p><a href="https://www.cloudflare.com/zh-cn/">cloudfare</a> 是国外一家CDN服务商，对于个人用户提供了一些免费的服务，可以把自己的网址托管在 <code>cloudfare</code> 上，可以通过优选</p><p>IP选择最优的CDN服务器，<a href="https://github.com/badafans/better-cloudflare-ip">优选IP可以参考这个github工程</a></p></li><li><p><a href="https://www.cloudflare.com/zh-cn/">cloudfare</a> 提供了worker反向代理功能，可以自定义添加worker，提供一个提升科学上网速度的脚本</p><pre><code class="language-js">addEventListener('fetch',event =&gt; {  let url=new URL(event.request.url);  url.hostname='xxxx.xx'; // v2ray服务器的伪装网址  let request=new Request(url,event.request);  event.respondWith(    fetch(request)  )})</code></pre></li></ul><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://www.cnblogs.com/taostaryu/p/10547132.html">https://www.cnblogs.com/taostaryu/p/10547132.html</a></p></li><li><p><a href="https://www.pianshen.com/article/9900131597/">https://www.pianshen.com/article/9900131597/</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARP攻击(网关欺骗)</title>
      <link href="/2021/06/20/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
      <url>/2021/06/20/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<p>​最近家中的网络一直不稳定，360报ARP攻击，重新插拔网线网络会通一段时间，但是过一会又不行了，遂了解了相关的背景知识。中间的曲折就不说了，最后具体原因是家中的组网是二级路由，两个路由都开启了DHCP分配地址，由于组网问题造成局域网中有两个网关。解决办法也很简单网上提供了2种方案。</p><p><img src="/2021/06/20/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/ac4bd11373f0820292b1b9c841fbfbedab641b21.png" alt="二级路由"></p><ul><li>第一种就是重新进行组网</li></ul><pre><code>[二级路由组网方案](https://www.dgzj.com/baike/92924.html)。</code></pre><ul><li>我这里通过第二种方法通过arp命令强行绑定网关和mac地址来解决网关冲突问题。</li></ul><pre><code>[Window10强行绑定ip和Mac地址的命令](https://www.jianshu.com/p/8b3dba40556f?from=singlemessage)# netsh i i show in# netsh -c i i add ne idx ip mac</code></pre><p>​如果局域网中有一台恶意的主机伪装成网关就可以抓取局域网中所有的信息，在局域网要注意个人信息的安全，最好绑定使用arp命令绑定网关。</p><pre><code>## 扩展阅读[Arp攻击 Arpspoof](https://www.jianshu.com/p/bbf50dace855)  [Arp攻击原理](https://www.zhihu.com/question/20338649?sort=created)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARP </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
