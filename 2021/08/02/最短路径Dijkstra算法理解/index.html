<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>最短路径Dijkstra算法</title><meta name="description" content="study hungry, study foolish"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js?v=undefined"><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}
</script></script><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="Dijkstra算法简介
​	Dijkstra算法算是贪心思想实现的，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。

算法核心


选择一个节点标记成已经遍历


选择从起点到其他节点路径最短的节点，如图所示起始点0到1、2、3的距离分别为5、2、6，当前不可达的4记作无穷大，则下一个被选择的节点就是2





在遍历过程中更新起始点到其他节点的最短距离


从起始点0到1的距离为5，按照步骤一选取下个节点2后，0-&amp;gt;2-&amp;gt;1距离比0-&amp;gt;1距离要短（这里已经间接说明为什么第一步要选择2的原因了），需要将距离由.."><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="study hungry,study foolish" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">未知数的博客</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">最短路径Dijkstra算法</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="toc-text">Dijkstra算法简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%A0%B8%E5%BF%83"><span class="toc-text">算法核心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-text">算法实现</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/Dijkstra"><i class="tag post-item-tag">Dijkstra</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">最短路径Dijkstra算法</h1><time class="has-text-grey" datetime="2021-08-02T11:35:33.000Z">2021-08-02</time><article class="mt-2 post-content"><h2 id="Dijkstra算法简介">Dijkstra算法简介</h2>
<p>​	Dijkstra算法算是<strong>贪心思想</strong>实现的，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。</p>
<hr>
<h2 id="算法核心">算法核心</h2>
<ul>
<li>
<p>选择一个节点标记成已经遍历</p>
<ul>
<li>
<p>选择从起点到其他节点路径最短的节点，如图所示起始点0到1、2、3的距离分别为5、2、6，当前不可达的4记作无穷大，则下一个被选择的节点就是2</p>
<p><img src="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/1627869608-ZNeWka-image.png" alt="图1"></p>
</li>
</ul>
</li>
<li>
<p>在遍历过程中更新起始点到其他节点的最短距离</p>
<ul>
<li>
<p>从起始点0到1的距离为5，按照步骤一选取下个节点2后，0-&gt;2-&gt;1距离比0-&gt;1距离要短（这里已经间接说明为什么第一步要选择2的原因了），需要将距离由5更新为3</p>
<p><img src="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/1627869851-VtwdFS-image.png" alt="图2"></p>
</li>
</ul>
</li>
<li>
<p>Dijkstra算法终止条件：遍历完毕所有可达的节点</p>
<p><img src="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/1627869914-XQvKqz-image.png" alt="图3"></p>
</li>
</ul>
<hr>
<h2 id="算法实现">算法实现</h2>
<p>LeetCode题目<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a>，这里我直接用优先队列来实现节点的选择，更能说明问题。</p>
<pre><code class="language-c++">class Solution {
public:
    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k) 
    {
        vector&lt;int&gt; dis(n + 1, -1); 
        dis[k] = 0;

        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; // 元素递增
        pq.push(make_pair(0, k)); // first:距离, second:节点编号

        while (!pq.empty()) {
            pair&lt;int, int&gt; dst = pq.top();
            pq.pop(); // 选取优先队列中第一个节点，即从起点到其他节点路径最短的节点

            if (dst.first &gt; dis[dst.second]) { // 当前达到dst的权值比记录的还要大，则不可能是最短路径
                continue;
            }

            for (int i = 0; i &lt; times.size(); i++) {
                if (times[i][0] != dst.second) {
                    continue;
                }
                // 遍历以dst为起点的路径
                int v = times[i][1];
                int w = dst.first + times[i][2];

                if (dis[v] == -1 || dis[v] &gt; w) {
                    dis[v] = w; // 更新距离
                    pq.push(make_pair(w, v));
                }
            }

        }

        int ans = 0;
        for (int i = 1; i &lt;= n; i++) {
            if (dis[i] == - 1) {
                return -1;
            }
            ans = max(ans, dis[i]);
        } 

        return ans;
    }
};
</code></pre>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2021/08/06/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/" title="集线器、交换机、路由器"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: 集线器、交换机、路由器</span></a><a class="button is-default" href="/2021/08/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/" title="Hexo + GitHub 搭建个人博客"><span class="has-text-weight-semibold">下一页: Hexo + GitHub 搭建个人博客</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> 未知数 2024</span></p><!--div.is-flex.is-justify-content-center.is-flex-wrap-wrap--><!--  p Powered by Hexo &verbar;&nbsp;--><!--  p.is-flex.is-justify-content-center--><!--    a(title="Hexo theme author" href='//github.com/haojen') Theme by Haojen&nbsp;--><!--  div(style="margin-top: 2px")--><!--    a(title="github-button" class="github-button" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true")--><!--div--><!--  span!= theme.user && theme.user.footnotes--></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>