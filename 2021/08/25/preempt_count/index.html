<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>preempt_count</title><meta name="description" content="study hungry, study foolish"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js?v=undefined"><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}
</script></script><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="​	preempt_count本质上是一个per-CPU的32位变量，preempt_count代表的是该进程是否可以被抢占，peermpt_count等于0的时候当前进程就可以被抢占，当小于0存在bug，大于0说明当前进程不可以被抢占。具体每一位含义如下图所示。



hardirq相关
​	preempt_count中的第16到19个bit表示hardirq count，它记录了进入hardirq/top half的嵌套次数。irq_enter()用于标记hardirq的进入，此时hardirq count的值会加1。irq_exit()用于标记hardirq的退出，hardirq count的值会相应的减1。如果hardirq count的值为正数，说明现在正处于hardirq上下文中，代码中可借助*.."><meta name="generator" content="Hexo 5.4.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="study hungry,study foolish" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">未知数的博客</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">preempt_count</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#hardirq%E7%9B%B8%E5%85%B3"><span class="toc-text">hardirq相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#softirq%E7%9B%B8%E5%85%B3"><span class="toc-text">softirq相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">上下文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/preempt_count"><i class="tag post-item-tag">preempt_count</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">preempt_count</h1><time class="has-text-grey" datetime="2021-08-25T13:08:43.000Z">2021-08-25</time><article class="mt-2 post-content"><p>​	<code>preempt_count</code>本质上是一个per-CPU的32位变量，<code>preempt_count</code>代表的是该进程是否可以被抢占，<code>peermpt_count</code>等于0的时候当前进程就可以被抢占，当小于0存在bug，大于0说明当前进程不可以被抢占。具体每一位含义如下图所示。</p>
<span id="more"></span>
<p><img src="/2021/08/25/preempt_count/v2-ef0af5be9cedb02bead54a28b4d31a5c_720w.jpg" alt="preempt_count"></p>
<hr>
<h2 id="hardirq相关">hardirq相关</h2>
<p>​	<code>preempt_count</code>中的第16到19个bit表示hardirq count，它记录了进入hardirq/top half的嵌套次数。irq_enter()用于标记hardirq的进入，此时hardirq count的值会加1。irq_exit()用于标记hardirq的退出，hardirq count的值会相应的减1。如果hardirq count的值为正数，说明现在正处于hardirq上下文中，代码中可借助**in_irq()**宏实现快速判断。注意这里的命名是"in_irq"而不是"in_hardirq"。</p>
<p>​	hardirq count占据4个bits，理论上可以表示16层嵌套，但现在Linux系统并不支持hardirq的嵌套执行，所以实际使用的只有1个bit。</p>
<pre><code class="language-c">#define hardirq_count()	 (preempt_count() &amp; HARDIRQ_MASK)
#define in_irq()  (hardirq_count())

#define __irq_enter()					\
	do {						\
		account_irq_enter_time(current);	\
		preempt_count_add(HARDIRQ_OFFSET);	\
		trace_hardirq_enter();			\
	} while (0)

#define __irq_exit()					\
	do {						\
		trace_hardirq_exit();			\
		account_irq_exit_time(current);		\
		preempt_count_sub(HARDIRQ_OFFSET);	\
	} while (0)

int __handle_domain_irq(struct irq_domain *domain, unsigned int hwirq,
			bool lookup, struct pt_regs *regs)
{
	struct pt_regs *old_regs = set_irq_regs(regs);
	unsigned int irq = hwirq;
	int ret = 0;

	irq_enter(); // 进入中断hardirq++
#ifdef CONFIG_HISI_BB
	irq_trace_hook(0, 0, hwirq);
	irq_register_hook(old_regs);
#endif

#ifdef CONFIG_IRQ_DOMAIN
	if (lookup)
		irq = irq_find_mapping(domain, hwirq);
#endif
	/*
	 * Some hardware gives randomly wrong interrupts.  Rather
	 * than crashing, do something sensible.
	 */
	if (unlikely(!irq || irq &gt;= nr_irqs)) {
		ack_bad_irq(irq);
		ret = -EINVAL;
	} else {
		generic_handle_irq(irq);
	}
#ifdef CONFIG_HISI_BB
	irq_trace_hook(1, 0, hwirq);
#endif
	irq_exit(); // 退出中断hardirq--
	set_irq_regs(old_regs);
	return ret;
}
</code></pre>
<hr>
<h2 id="softirq相关">softirq相关</h2>
<p>​	<code>preempt_count</code>中的第8到15个bit表示softirq count，它记录了进入softirq的嵌套次数，如果softirq count的值为正数，说明现在正处于softirq上下文中。由于softirq在单个CPU上是不会嵌套执行的，因此和hardirq count一样，实际只需要一个bit(bit 8)就可以了。但这里多出的7个bits并不是因为历史原因多出来的，而是另有他用。</p>
<pre><code class="language-c++">void irq_exit(void)
{
#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLED
	local_irq_disable();
#else
	WARN_ON_ONCE(!irqs_disabled());
#endif

	account_irq_exit_time(current);
	preempt_count_sub(HARDIRQ_OFFSET);
	if (!in_interrupt() &amp;&amp; local_softirq_pending())
		invoke_softirq(); // 退出中断前，判断当前上下文不是软中断和硬中断，才会触发软中断(同一个cpu软中断不可嵌套)

	tick_irq_exit();
	rcu_irq_exit();
	trace_hardirq_exit(); /* must be last! */
}

asmlinkage __visible void __softirq_entry __do_softirq(void)
{
	unsigned long end = jiffies + MAX_SOFTIRQ_TIME;
	unsigned long old_flags = current-&gt;flags;
	int max_restart = MAX_SOFTIRQ_RESTART;
	struct softirq_action *h;
	bool in_hardirq;
	__u32 pending;
	int softirq_bit;

	/*
	 * Mask out PF_MEMALLOC s current task context is borrowed for the
	 * softirq. A softirq handled such as network RX might set PF_MEMALLOC
	 * again if the socket is related to swap
	 */
	current-&gt;flags &amp;= ~PF_MEMALLOC;

	pending = local_softirq_pending();
	account_irq_enter_time(current);

	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET); // 进入软中断前softirq++
	in_hardirq = lockdep_softirq_start();

restart:
	/* Reset the pending bitmask before enabling irqs */
	set_softirq_pending(0);

	local_irq_enable();

	h = softirq_vec;

	while ((softirq_bit = ffs(pending))) {
		unsigned int vec_nr;
		int prev_count;

		h += softirq_bit - 1;

		vec_nr = h - softirq_vec;
		prev_count = preempt_count();

		kstat_incr_softirqs_this_cpu(vec_nr);

		trace_softirq_entry(vec_nr);
		h-&gt;action(h);
		trace_softirq_exit(vec_nr);
		if (unlikely(prev_count != preempt_count())) {
			pr_err("huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\n",
			       vec_nr, softirq_to_name[vec_nr], h-&gt;action,
			       prev_count, preempt_count());
			preempt_count_set(prev_count);
		}
		h++;
		pending &gt;&gt;= softirq_bit;
	}

	rcu_bh_qs();
	local_irq_disable();

	pending = local_softirq_pending();
	if (pending) {
		if (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp;
		    --max_restart)
			goto restart;

		wakeup_softirqd();
	}

	lockdep_softirq_end(in_hardirq);
	account_irq_exit_time(current);
	__local_bh_enable(SOFTIRQ_OFFSET); // 退软中断前softirq--
	WARN_ON_ONCE(in_interrupt());
	current_restore_flags(old_flags, PF_MEMALLOC);
}
</code></pre>
<p>​	这个"他用"就是表示在进程上下文中，为了防止进程被softirq所抢占，关闭/禁止softirq的次数，比如每使用一次local_bh_disable()，softirq count高7个bits(bit 9到bit 15)的值就会加1，使用local_bh_enable()则会让softirq count高7个bits的的值减1。</p>
<p>​	代码中可借助**in_softirq()**宏快速判断当前是否在softirq上下文：</p>
<pre><code class="language-c">#define softirq_count()  (preempt_count() &amp; SOFTIRQ_MASK)
#define in_softirq()	 (softirq_count())
</code></pre>
<hr>
<h2 id="上下文">上下文</h2>
<p>​	**in_interrupt()**的宏专门用来判断当前是否在中断上下文中</p>
<pre><code class="language-c">#define irq_count()	 (preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK | NMI_MASK))			 
#define in_interrupt()  (irq_count())
</code></pre>
<p>与中断上下文相对应的就是俗称的进程上下文(process context)</p>
<pre><code class="language-c">#define in_task()  (!(preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_OFFSET | NMI_MASK)))
</code></pre>
<p>​	在中断上下文中，调度是关闭的，不会发生进程的切换，这属于一种隐式的禁止调度，而在代码中，也可以使用preempt_disable()来显示地关闭调度，关闭次数由第0到7个bits组成的preemption count(注意不是preempt count)来记录。每使用一次preempt_disable()，preemption count的值就会加1，使用preempt_enable()则会让preemption count的值减1。preemption count占8个bits，因此一共可以表示最多256层调度关闭的嵌套。</p>
<p>​	处于中断上下文，或者显示地禁止了调度，preempt_count()的值都不为0，都不允许睡眠/调度的发生，这两种场景被统称为atomic上下文，可由**in_atomic()**宏给出判断。</p>
<pre><code class="language-go">#define in_atomic()	(preempt_count() != 0)
</code></pre>
<p>​	中断上下文、进程上下文和atomic上下文的关系大概可以表示成这样：</p>
<p><img src="/2021/08/25/preempt_count/v2-3d4d6ecfcdec4be8c270dadfea0bd29a_720w.jpg" alt="中断上下文、进程上下文和atomic上下文的关系"></p>
<hr>
<h2 id="参考链接">参考链接</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/88883239">https://zhuanlan.zhihu.com/p/88883239</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1J64y1r7mK">linux内核开发第31讲：中断上下文、进程上下文环境的进入时机</a></p>
</li>
</ul>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2021/08/19/%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/" title="Linux nice 命令"><span class="has-text-weight-semibold">下一页: Linux nice 命令</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> 未知数 2021</span></p><!--div.is-flex.is-justify-content-center.is-flex-wrap-wrap--><!--  p Powered by Hexo &verbar;&nbsp;--><!--  p.is-flex.is-justify-content-center--><!--    a(title="Hexo theme author" href='//github.com/haojen') Theme by Haojen&nbsp;--><!--  div(style="margin-top: 2px")--><!--    a(title="github-button" class="github-button" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true")--><!--div--><!--  span!= theme.user && theme.user.footnotes--></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>