<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>study hungry,study foolish</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-08-16T13:41:36.196Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内核内核中的锁</title>
    <link href="http://example.com/2021/08/16/%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>http://example.com/2021/08/16/%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/</id>
    <published>2021-08-16T13:41:33.000Z</published>
    <updated>2021-08-16T13:41:36.196Z</updated>
    
    <content type="html"><![CDATA[<p>​内核中自旋锁、信号量/mutex、读写锁/顺序锁、RCU介绍。</p><span id="more"></span><h3 id="1-自旋锁">1.自旋锁</h3><h5 id="为什么需要自旋锁">为什么需要自旋锁</h5><p>​很多时候我们并不能采用其他的锁，比如读写锁、互斥锁、信号量等。一方面这些锁会发生上下文切换，他的时间是不可预期的，对于一些简单的、极短的临界区完全是一种性能损耗；另一方面在中断上下文是不允许睡眠的，除了自旋锁以外的其他任何形式的锁都有可能导致睡眠或者进程切换，这是违背了中断的设计初衷，会发生不可预知的错误。基于两点，我们需要自旋锁，他是不可替代的。</p><h5 id="为什么自旋锁会禁止抢占">为什么自旋锁会禁止抢占</h5><p>​这一点其实很好理解，当一个 CPU 获取到一把自旋锁之后，开始执行临界区代码，此时假设他的时间片运转完毕，进程调度会主动触发调度将其调走，执行另一个线程/进程，结果恰巧了这个线程/进程也需要用到该自旋锁，而上一个线程/进程还在停留在临界区内未释放锁，导致本进程无法获取到锁而形成死锁，所以自旋锁为了规避此类情形的出现从而直接禁止对已经开始运行的临界区设置禁止抢占标志。</p><h5 id="为什么临界区禁止睡眠">为什么临界区禁止睡眠</h5><p>​如果自旋锁锁住以后进入睡眠，而此时又不能进行处理器抢占，内核的调取器无法调取其他进程获得该 CPU，从而导致该 CPU 被挂起；同时该进程也无法自唤醒且一直持有该自旋锁，进一步会导致其他使用该自旋锁的位置出现死锁。</p><h4 id="spin-lock-系列的分别">spin_lock 系列的分别</h4><p>​每一种锁出现都有自己的原因，spin_lock 系列的锁就是为了解决这一个又一个的问题才会新增的各种自旋锁变种，这也符合现代计算机代码设计逻辑，首先是解决有无问题之后再解决崩溃问题，最后才是性能问题，没有什么设计能够逃得出这样一个框架。</p><p>​spin_lock 出现的原因上文已经介绍过了，目标就是为了解决当前内核中，某些场景下快速访问临界区的问题而存在的，所以他禁止了调度器抢占，所以不存在任何其他的进程会抢占该 CPU 的情况。但是，现代计算机为了能够更快的响应各种外部消息，所以存在各种类型的中断，比如网卡中断的到来，就一定会打断正在执行的 CPU 的进程，哪怕是当前的程序被 spin_lock 给锁住了，假设当前的中断也需要访问该 spin_lock 锁，那么就会导致死锁发生，如图：</p><p><a href="https://i.loli.net/2018/09/20/5ba3446040187.png"><img src="/2021/08/16/%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/5ba3446040187.png" alt="img"></a></p><p>所以为了应对自旋锁同时出现在硬件中断和进程上下文的情况，所以应该在进程执行临界区代码段的自旋锁上锁之前，首先就应该关闭当前 CPU 的中断，这样无论你发生什么情况，一旦被锁上就不再会被任何的情况抢走 CPU，这就是 spin_lock_irq 出现的原因，当然，由于需要关闭中断，会导致系统的响应降低，而且还会执行更多的代码，可能会导致性能下降。</p><p>​那么 spin_lock_irqsave 又为何需要存在，之前说过每一种类型变种的出现都是为了解决实际问题，那么这个类型锁的出现也是为了解决一些实际问题。如图所示：</p><p><a href="https://i.loli.net/2018/09/20/5ba346d89fbd6.png"><img src="/2021/08/16/%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/5ba346d89fbd6.png" alt="img"></a></p><p>​从图中可以看出，当进程在执行第一个 spin_lock_irq(&amp;lock1) 时已经关闭了中断，然后继续获取第二个自旋锁spin_lock_irq(&amp;lock2)，当 lock2 解锁后且 lock1 未解锁前这一段区域处于一种硬件中断开启的状态，这段代码仍然处于 lock1 的临界区，如果此时硬件中断也需要申请 lock1 锁会导致死锁，这是因为 spin_unlock_irq 在解锁时一定会将本地 CPU 的中断打开，从而导致硬件中断可以重新强制抢占 CPU，所以最好的方式就是 lock2 在锁之前保存当前的中断状态，在解锁时恢复当前的中断状态，这也就是 spin_lock_irqsave 需要存在的原因。自然地，这是一种更为线程安全的方案，但是他会带来比前面几种更加多的性能损耗。</p><h4 id="什么场合使用什么类型的自旋锁">什么场合使用什么类型的自旋锁</h4><p>既然都已经了解了三种自旋锁的变种，那么什么情况下适合什么样的锁呢？</p><h5 id="spin-lock-使用场景">spin_lock 使用场景</h5><p>​首先如果整个临界区都只位于进程上下文或者工作队列中，那么只需要采用最为方便的 spin_lock 即可，因为他不会发生中断抢占锁的情况，哪怕中断抢占进程上下文也不会导致中断由于申请自旋锁而导致死锁。</p><p>​还有一种情况就是在硬件中断中可以考虑使用 spin_lock 即可，因为硬件中断不存在嵌套（未必一定是这样，与平台有关），所以只需要简单的上锁即可， 可以不需要关闭中断，保存堆栈等。</p><h5 id="spin-lock-irq-使用场景">spin_lock_irq 使用场景</h5><p>​这个锁的变种适合在进程上下文/软中断 + 硬件中断这样的组合中使用，taskset 也是属于软中断的一种，所以也归在此类。当然，这种类型的变种同样适合软中断/taskset + 进程上下文的组合，因为关闭了硬件中断，从源头就禁止执行软中断代码，不过，对于这种类型的中断最好的方式是使用 spin_lock_bh 的方式，因为他只锁定软中断代码执行，而不关闭硬件中断，这样性能损耗更小。</p><h5 id="spin-lock-irqsave-使用场景">spin_lock_irqsave 使用场景</h5><p>​这种类型的使用方式是最为安全以及便捷的，毕竟不需要考虑会不会发生死锁的问题（代码本身引入的死锁不在此类），但是他也是性能损耗最大的代码，能不使用尽量不适用，在高速设备上，自旋锁已然成为了一种降低性能的瓶颈。他最好只出现在在需要尝试 spin_lock 之前无法确定是否已经关闭中断的代码才使用，如果代码能够确定在执行锁之前中断一定是打开的，那么使用 spin_lock_irq 是更佳的选择。</p><h5 id="spin-lock-bh-使用场景">spin_lock_bh 使用场景</h5><p>​这种类型的变种是一种比 spin_lock_irq 更轻量的变种，只关闭中断底半部，其实就是关闭了软中断、Taskset 以及 Timer 等的一个抢占能力，如果开发者确定编写的代码临界区只存在软中断/Taskset/Timer + 进程上下文这样的组合，则最好考虑使用 spin_lock_bh 这样的锁来禁止软中断进行抢占。还有就是软中断与软中断自我抢占临界区访问时，也需要使用 spin_lock_bh 以上的中断锁，因为有可能软中断在执行的过程中，自己被硬件中断打断，然后又执行到同样的代码，在别的 CPU 执行还好说，毕竟软中断可以在不同的 CPU 上执行同一个中断函数，但是假设不幸运行在同一个 CPU 上，则会导致死锁。Taskset 由于在运行过程中钟只会运行一个实例，所以不存在死锁问题，Taskset 与 Taskset 的锁竞争只需要使用 spin_lock 即可。</p><h3 id="2-信号量和mutex">2.信号量和mutex</h3><p>​网上有一篇关于信号量和mutex的深入分析的介绍 ，最后作者有一段总结：</p><p>​具体可以参照：<a href="https://blog.csdn.net/weixin_32521765/article/details/116923700">https://blog.csdn.net/weixin_32521765/article/details/116923700</a></p><p>​<em><strong>我们看到对mutex的优化其实遵循了代码优化的一般原则，即集中优化整个代码执行中出现的hot-spot(引申到高概率spot)。因为在</strong></em></p><p><em><strong>实际使用当中，大多数情况 下，mutex_lock与mutex_unlock之间的代码都比较简短，使得获得锁的进程可以很快释放锁(因此，从性</strong></em></p><p><em><strong>能优化的角度，这个也可以作为使 用mutex的一条一般原则)。如果系统中大部分拥有互斥锁的进程在mutex_lock与unlock之间执行时</strong></em></p><p><em><strong>间比较长，那么相对于使用 semaphore，我相信使用mutex会使得系统性能降低：因为很大的概率，mutex都经过一段spin(虽然这</strong></em></p><p><em><strong>段时间极短)之后最终还是进入 sleep，而semaphore则直接进入sleep，没有了spin的过程。</strong></em></p><h3 id="3-读写锁和顺序锁">3. 读写锁和顺序锁</h3><pre><code class="language-c">//定义读写锁rwlock_t rwlock;//初始化读写锁rwlock_init(&amp;rwlock);//读锁定read_lock(&amp;rwlock);//读锁定并关闭中断read_lock_irq(&amp;rwlock);//读解锁read_unlock(&amp;rwlock);//读解锁并恢复中断read_unlock_irqrestore(&amp;rwlock);//写锁定write_lock(&amp;rwlock);//写锁定并关闭中断write_lock_irq(&amp;rwlock);//写解锁write_unlock(&amp;rwlock);//写解锁并恢复中断write_unlock_irqrestore(&amp;rwlock);</code></pre><pre><code class="language-c">//定义顺序锁seqlock_t seq_lock;//初始化顺序锁seqlock_init(&amp;seq_lock);//写锁定write_seqlock(seqlock_t * sl);write_seqlock_irq(seqlock_t * sl);//写解锁write_sequnlock(seqlock_t * sl);write_sequnlock_irqrestore(seqlock_t * sl);//读申请unsigned int read_seqbegin(const seqlock_t * sl);//读有效判定int read_seqretry(const seqlock_t * sl, unsigned start);//demodo{    unsigned int seqnum=read_seqbegin(&amp;seqlock);    //读操作&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; .}while(read_seqretry(&amp;seqlock,seqnum));</code></pre><ul><li><p>读写锁和顺序锁相同点：读操作和读操作不互斥、读写互斥、写写互斥</p></li><li><p>读写锁和顺序锁不同点：读写锁读优先，即写操作会等所有读操作完成，才会进入；顺序锁写优先，demo中的 <code>do while</code>就是读者发现写操作修改数据，尝试再次读取。即如果当前有其他读操作，写操作也会执行。</p></li></ul><h3 id="4-RCU">4.RCU</h3><p>​RCU在驱动中用的相对比较少，可以参考这篇文章：<a href="https://blog.csdn.net/xabc3000/article/details/15335131">https://blog.csdn.net/xabc3000/article/details/15335131</a></p><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://www.byteisland.com/%E8%87%AA%E6%97%8B%E9%94%81-spin_lock%E3%80%81-spin_lock_irq-%E4%BB%A5%E5%8F%8A-spin_lock_irqsave-%E7%9A%84%E5%8C%BA%E5%88%AB/">自旋锁 spin_lock、 spin_lock_irq 以及 spin_lock_irqsave 的区别</a></p></li><li><p><a href="https://blog.csdn.net/weixin_32521765/article/details/116923700">linux semaphore性能,深层次探讨mutex与semaphore之间的区别</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	内核中自旋锁、信号量/mutex、读写锁/顺序锁、RCU介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>如何Review代码</title>
    <link href="http://example.com/2021/08/15/%E5%A6%82%E4%BD%95review%E4%BB%A3%E7%A0%81/"/>
    <id>http://example.com/2021/08/15/%E5%A6%82%E4%BD%95review%E4%BB%A3%E7%A0%81/</id>
    <published>2021-08-15T06:15:34.000Z</published>
    <updated>2021-08-15T06:17:47.742Z</updated>
    
    <content type="html"><![CDATA[<h1>review 前准备</h1><ul><li>代码开发人员做好自review和自测试，杜绝代码中的低级错误</li><li>参加review的人员需要对代码业务有一定的了解，代码开发人员提前做好方案详细设计串讲</li><li>完成部分代码即可发起review，小步快跑，减少每次review代码量</li></ul><h1>review什么</h1><ul><li>专项review：参考《C/C++编程规范》、《C/C++安全编程规范》，这部分在开发人员自review时就应该做好</li><li>功能review：代码实现是否满足需求</li><li>可读性：圈复杂度、变量名命名合理、目录划分、函数代码行数、无冗余代码等等</li><li>可维护性/可扩展：数据结构/接口定义合理、兼容其他平台、提供测试接口、提供相关关键日志</li><li>性能review：算法实现是否最优，是否有执行效率低的代码等</li></ul><h1>写在最后</h1><p>​对于代码要做到<strong>谁开发，谁保护；谁污染，谁治理</strong>。对产品代码划分责任田，责任田主对代码的质量长期负责。之前和若干合作方合作过，合作方交付的代码质量堪忧，我认为其中一条就是合作方不对代码质量长期负责，合作方交付代码之后就没人管了。第一版代码的开发人员对代码的日后演进有至关重要的作用，如果第一版质量就很差，以后代码问题会像滚雪球一样问题越来越严重。一个Cisco来的专家讲过他们review代码方式：每个源码文件都有相关的review人员，这些人员都是当初开发这段代码的人员或者维护过这段代码的人员，无论他们目前在公司做什么工作，一旦有人改了这段代码，这些人都会收到相关的邮件review通知。他就曾经半夜收到某大领导的电话，这个人多年前曾维护过这段代码，给他提了好多有效的review意见。</p><p>​最后的最后，代码的质量决定的根本因素还是开发代码人员，一个程序员的基本素养是啥？自己埋下的坑自己填，自己的BUG自己能解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;review 前准备&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;代码开发人员做好自review和自测试，杜绝代码中的低级错误&lt;/li&gt;
&lt;li&gt;参加review的人员需要对代码业务有一定的了解，代码开发人员提前做好方案详细设计串讲&lt;/li&gt;
&lt;li&gt;完成部分代码即可发起review，小</summary>
      
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>内核同步机制：自旋锁</title>
    <link href="http://example.com/2021/08/08/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E8%87%AA%E6%97%8B%E9%94%81/"/>
    <id>http://example.com/2021/08/08/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E8%87%AA%E6%97%8B%E9%94%81/</id>
    <published>2021-08-08T13:47:19.000Z</published>
    <updated>2021-08-08T13:49:00.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自旋锁系列函数">自旋锁系列函数</h2><table><thead><tr><th>函数</th><th>功能说明</th></tr></thead><tbody><tr><td>void spin_lock(spinlock_t *lock)</td><td>进程和进程之间同步</td></tr><tr><td>void spin_lock_bh(spinlock_t *lock)</td><td>和本地软中断之间同步</td></tr><tr><td>void spin_lock_irq(spinlock_t *lock)</td><td>和本地硬件中断之间同步</td></tr><tr><td>void spin_lock_irqsave(lock, flags)</td><td>和本地硬件中断之间同步并保存本地中断状态</td></tr><tr><td>int spin_trylock(spinlock_t *lock)</td><td>尝试获取锁，如果成功返回非0值，否则返回0值</td></tr></tbody></table><hr><h2 id="自旋锁特点">自旋锁特点</h2><ul><li><code>spinlock</code>是一种死等的锁机制</li><li>临界区执行时间短且不可睡眠，可以在中断上下文中使用。由于<code>spinlock</code>死等的这种特性，如果临界区执行时间长，那么不断在临界区死等的执行单元会浪费CPU资源</li></ul><hr><h2 id="自旋锁的公平性">自旋锁的公平性</h2><pre><code class="language-c">typedef struct spinlock {union {struct raw_spinlock rlock;#ifdef CONFIG_DEBUG_LOCK_ALLOC# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))struct {u8 __padding[LOCK_PADSIZE];struct lockdep_map dep_map;};#endif};} spinlock_t;typedef struct raw_spinlock {arch_spinlock_t raw_lock;#ifdef CONFIG_GENERIC_LOCKBREAKunsigned int break_lock;#endif#ifdef CONFIG_DEBUG_SPINLOCKunsigned int magic, owner_cpu;void *owner;#endif#ifdef CONFIG_DEBUG_LOCK_ALLOCstruct lockdep_map dep_map;#endif} raw_spinlock_t;typedef struct {union {u32 slock;struct __raw_tickets {#ifdef __ARMEB__u16 next;u16 owner;#elseu16 owner; // owner表示持有这个数字的thread可以获取自旋锁u16 next; // next表示如果后续再有thread请求获取这个自旋锁，就给他分配这个数字#endif} tickets;};} arch_spinlock_t;</code></pre><ul><li><p>数据结构：spinlock_t --&gt; raw_spinlock_t --&gt; arch_spinlock_t</p></li><li><p>自旋锁公平调度实现方式</p><ul><li>刚开始owner = next = 0</li><li>第一个thread获取spinlock，可以获取成功，此时owner = 0， next = 0</li><li>第二个thread获取spinlock，如果第一个thread还没有释放spinlock，则next++，next变为1</li><li>第三个thread获取spinlock，如果第一个thread还没有释放spinlock，则next++，next变为2</li><li>此时第一个thread释放spinlock，则执行owner++，owner = 1</li><li>虽然此时第二个thread和第三个thread都在等待spinlock，但是因为第二个thread的next=owner，所以第二个thread可以获取到spinlock，第三个thread则继续等待，这样保证了spinlock的唤醒机制是先到先唤醒，后到后唤醒，保证了公平性。</li></ul><pre><code class="language-c">static inline void arch_spin_lock(arch_spinlock_t *lock){unsigned long tmp;u32 newval;arch_spinlock_t lockval;prefetchw(&amp;lock-&gt;slock);    // 下面这段汇编翻译成C语言就是    /*    lockval = lock-&gt;slock;    newval = lockval + (1 &lt;&lt; TICKET_SHIFT) &lt;=等价于=&gt; newval.ticket.next = lockval.tickets.next++    lockval = newval    */__asm__ __volatile__("1:ldrex%0, [%3]\n""add%1, %0, %4\n""strex%2, %1, [%3]\n""teq%2, #0\n""bne1b": "=&amp;r" (lockval), "=&amp;r" (newval), "=&amp;r" (tmp): "r" (&amp;lock-&gt;slock), "I" (1 &lt;&lt; TICKET_SHIFT): "cc");while (lockval.tickets.next != lockval.tickets.owner) { // 死等循环，直到 owner == nextwfe(); // cpu进入低功耗状态lockval.tickets.owner = ACCESS_ONCE(lock-&gt;tickets.owner);}smp_mb();}</code></pre></li></ul><hr><h2 id="参考链接">参考链接</h2><ul><li><p>自旋锁Spinlock <a href="https://blog.csdn.net/longwang155069/article/details/52055876">https://blog.csdn.net/longwang155069/article/details/52055876</a></p></li><li><p>linux内核开发第18讲：spinlock在SMP下的源码实现 <a href="https://www.bilibili.com/video/BV1Yh411R7YC">https://www.bilibili.com/video/BV1Yh411R7YC</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自旋锁系列函数&quot;&gt;自旋锁系列函数&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;功能说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;void spin_lock(spinlock_t *lock</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="自旋锁" scheme="http://example.com/tags/%E8%87%AA%E6%97%8B%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>H.265/HEVC环路滤波技术</title>
    <link href="http://example.com/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/"/>
    <id>http://example.com/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/</id>
    <published>2021-08-07T13:52:53.000Z</published>
    <updated>2021-08-07T13:56:25.191Z</updated>
    
    <content type="html"><![CDATA[<p>​<code>H.265/HEVC</code> 仍然采用基于块的混合编码框架，方块效应、振铃效应、颜色偏差以及图像模糊等失真效应仍存在。为降低这类失真对视频的影响，<code>H.265/HEVC</code>采用环路滤波技术，包括去方块滤波（Deblocking Filter）和像素自适应补偿（Sample Adaptive Offset）两个模块。去方块滤波用于降低方块效应，像素自适应补偿用于改善振铃效应。如图所示可以看出，经过滤波的重构像素才能作为后续编码像素参考使用。环路滤波处理后的重建图像更有利于参考，进一步减小后续编码像素的预测残差，可有效地提高视频的主观质量。</p><span id="more"></span><p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2.png" alt="环路滤波"></p><hr><h2 id="块效应">块效应</h2><p>块效应是指图像中编码块编解不连续，如图所示，压缩重建图像有明显的方块效应，严重影响主观质量。</p><p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/421096-20160518153202404-1659522803.gif" alt="img"></p><hr><h3 id="块效应产生原因">块效应产生原因</h3><ul><li>各个块变换量化编码过程独立，相当于对各个块使用了不同参数的滤波器分别滤波，因此各块引入的量化误差大小及其分布特征相互独立，导致相邻编解的不连续。</li><li>运动补偿预测过程中，相邻块的预测值可能来自不同图像的不同位置，这样就导致预测残差信号在块的边界产生数值不连续。</li><li>时域预测技术使得参考图像中窜在的边界不连续可能会传递到后续编码图像</li></ul><hr><h3 id="去方块滤波技术">去方块滤波技术</h3><p>​滤波的主要工作就是判断块边界是否需要进行滤波，并且决定采用的滤波强度（大白话就是对边界多少个像素进行平滑，即取均值）。过强的滤波会造成图像细节不必要的平滑，而缺乏滤波则会造成块效应。</p><ul><li>确定滤波边界</li><li>计算边界强度</li><li>对亮度分量进行滤波开关决策、滤波强弱选择</li><li>滤波</li></ul><hr><h2 id="振铃效应">振铃效应</h2><p>所谓“振铃”，就是指输出图像的灰度剧烈变化处产生的震荡，就好像钟被敲击后产生的空气震荡。</p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/振铃效应.png" alt="振铃效应" style="zoom:200%;"><hr><h3 id="振铃效应产生原因">振铃效应产生原因</h3><ul><li><p><code>H.265/HEVC</code> 采用基于块的<code>DCT</code>变换，并在频域对变换系数进行量化。对于强边缘，由于高频系数的量化失真，解码后会在边缘周围产生波纹现象，造成此现象的根本原因是高频信息丢失。如图所示，实线中的高频信息丢失后变成了虚线（实线表示原始像素值，虚线表示重构像素值）。可以看出重构像素值在边缘两侧上下波动。</p><p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/%E6%8C%AF%E9%93%83%E6%95%88%E5%BA%942.png" alt="振铃效应"></p></li></ul><hr><h3 id="像素自适应补偿">像素自适应补偿</h3><p>像素值原来是平坦区，因为量化丢弃了部分高频分量，形成了某些像素值得偏移，使得原来相对平坦的像素值关系或多或少地形成局部峰点、谷点或拐点。那么，像素自适应补偿就是人为地对这些飘逸的像素加上一个适当的相反的补偿量，以抵消编码造成的偏移。</p><p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/3596589-2c845f743b4e20a3.png" alt="img"></p><hr><h2 id="参考链接">参考链接</h2><ul><li><p>5.H.265/HEVC—— 环路后处理 <a href="https://www.jianshu.com/p/1de7e26001f4">https://www.jianshu.com/p/1de7e26001f4</a></p></li><li><p>新一代高效视频编码H.265HEVC原理、标准与实现 [万帅，杨付正 编著] 2014年版</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	&lt;code&gt;H.265/HEVC&lt;/code&gt; 仍然采用基于块的混合编码框架，方块效应、振铃效应、颜色偏差以及图像模糊等失真效应仍存在。为降低这类失真对视频的影响，&lt;code&gt;H.265/HEVC&lt;/code&gt;采用环路滤波技术，包括去方块滤波（Deblocking Filter）和像素自适应补偿（Sample Adaptive Offset）两个模块。去方块滤波用于降低方块效应，像素自适应补偿用于改善振铃效应。如图所示可以看出，经过滤波的重构像素才能作为后续编码像素参考使用。环路滤波处理后的重建图像更有利于参考，进一步减小后续编码像素的预测残差，可有效地提高视频的主观质量。&lt;/p&gt;</summary>
    
    
    
    <category term="视频" scheme="http://example.com/categories/%E8%A7%86%E9%A2%91/"/>
    
    
    <category term="去块滤波" scheme="http://example.com/tags/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2/"/>
    
    <category term="像素自适应补偿" scheme="http://example.com/tags/%E5%83%8F%E7%B4%A0%E8%87%AA%E9%80%82%E5%BA%94%E8%A1%A5%E5%81%BF/"/>
    
  </entry>
  
  <entry>
    <title>集线器、交换机、路由器</title>
    <link href="http://example.com/2021/08/06/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"/>
    <id>http://example.com/2021/08/06/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/</id>
    <published>2021-08-06T14:14:00.000Z</published>
    <updated>2021-08-06T15:02:50.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="早期网络设备集线器HUB">早期网络设备集线器HUB</h2><h3 id="集线器特点">集线器特点</h3><ul><li>集线器工作于物理层，所有端口同属一个碰撞域和广播域，每个端口仅对数据信号进行放大和转发</li><li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用 <code>CSMA/CD</code> 协议处理总线竞争访问</li><li>由于工作在数据链路层的交换机比集线器性能更高，故集线器已经逐渐被淘汰</li></ul><h3 id="CSMA-CD-和-CSMA-CA-协议"><code>CSMA/CD</code> 和 <code>CSMA/CA</code> 协议</h3><ul><li><code>CSMA/CD</code> 是有线局域网解决总线竞争访问的协议，目前由于交换器的使用这个协议逐渐也被淘汰</li><li><code>CSMA/CA</code> 是无线局域网解决竞争访问的协议，目前仍广泛使用</li></ul><hr><h2 id="交换机SWITCH">交换机SWITCH</h2><h3 id="交换机特点">交换机特点</h3><ul><li><p>交换机工作于数据链路层（也包括物理层），根据MAC地址对帧进行转发</p></li><li><p>交换机的每个接口都是独立的碰撞域，交换机只隔离碰撞域不隔离广播域</p><p><img src="/2021/08/06/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/d058ccbf6c81800aab934511b13533fa828b47bf" alt="交换机"></p></li></ul><h3 id="交换表">交换表</h3><ul><li><p>交换机有一张交换表，表中记录的是<strong>帧的目的MAC地址所对应的接口号</strong>，然后通过该接口转发数据帧</p></li><li><p>刚上电时交换机中的交换表是空的，此时交换机会将从某个接口收到的数据流向除该接口之外的所有接口发送出去（泛洪），随着网络中各主机间的通信，以太网交换机通过<strong>自学习算法</strong>逐渐建立起帧交换表</p></li><li><p>扩展阅读：MAC泛洪攻击和防御 <a href="https://blog.csdn.net/pygain/article/details/52059238">https://blog.csdn.net/pygain/article/details/52059238</a></p></li></ul><h3 id="交换机生成树协议-STP">交换机生成树协议 <code>STP</code></h3><ul><li>为提高网络的可靠性，网络中添加了冗余链路，这些冗余链路可能会出现环路，网络环路会带来以下几个问题：<ul><li>广播风暴：大量消耗网络资源，使网络无法转发其他数据帧</li><li>主机收到重复的广播帧</li><li>交换机的真交换表震荡（漂移）</li></ul></li><li>以太网交换机使用生成树协议<code>STP</code>，可以在增加冗余链路提高网络可靠性的同时又避免网络环路<ul><li>不论交换机之间采用何种物理连接，交换机都能自动计算并构建一个逻辑上没有环路的网络</li><li>最终的生成网络确保可以连通整个网络</li><li>首次接入或者物理网络发生变化，交换机会进行生成树的重新计算</li></ul></li></ul><hr><h2 id="路由器">路由器</h2><h3 id="路由器特点">路由器特点</h3><ul><li><p>路由器工作在网络层，根据IP地址对报文进行转发</p></li><li><p>交换机不能分割广播域，路由可以</p></li><li><p>路由器实现了不同网络之间的数据转发，交换机实现了特定网络内的数据交换</p></li></ul><h3 id="路由表和转发表">路由表和转发表</h3><ul><li>路由表包含目的网络到下一跳的映射</li><li>路由表需要对网络拓扑变化的计算最优化</li><li>转发表是由路由表得出的</li><li>转发表的结构应该使查找过程最优化</li></ul><h3 id="路由选择协议">路由选择协议</h3><ul><li>静态路由选择：人工配置</li><li>动态路由选择：根据路由协议自动获取路由信息<ul><li>内部网关协议<ul><li>路由信息协议<code>RIP</code></li><li>内部网关路由协议<code>IGRP</code></li><li>增强型内部网关路由协议<code>EIGRP</code></li><li>开放式最短路径优先<code>OSPF</code></li><li>中间系统到中间系统<code>IS-IS</code></li></ul></li><li>外部网关协议<ul><li>边界网关协议<code>BGP</code></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;早期网络设备集线器HUB&quot;&gt;早期网络设备集线器HUB&lt;/h2&gt;
&lt;h3 id=&quot;集线器特点&quot;&gt;集线器特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;集线器工作于物理层，所有端口同属一个碰撞域和广播域，每个端口仅对数据信号进行放大和转发&lt;/li&gt;
&lt;li&gt;使用集线器的以太网在逻辑</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络设备" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>最短路径Dijkstra算法</title>
    <link href="http://example.com/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/</id>
    <published>2021-08-02T11:35:33.000Z</published>
    <updated>2021-08-02T16:18:44.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dijkstra算法简介">Dijkstra算法简介</h2><p>​Dijkstra算法算是<strong>贪心思想</strong>实现的，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。</p><hr><h2 id="算法核心">算法核心</h2><ul><li><p>选择一个节点标记成已经遍历</p><ul><li><p>选择从起点到其他节点路径最短的节点，如图所示起始点0到1、2、3的距离分别为5、2、6，当前不可达的4记作无穷大，则下一个被选择的节点就是2</p><p><img src="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/1627869608-ZNeWka-image.png" alt="图1"></p></li></ul></li><li><p>在遍历过程中更新起始点到其他节点的最短距离</p><ul><li><p>从起始点0到1的距离为5，按照步骤一选取下个节点2后，0-&gt;2-&gt;1距离比0-&gt;1距离要短（这里已经间接说明为什么第一步要选择2的原因了），需要将距离由5更新为3</p><p><img src="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/1627869851-VtwdFS-image.png" alt="图2"></p></li></ul></li><li><p>Dijkstra算法终止条件：遍历完毕所有可达的节点</p><p><img src="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/1627869914-XQvKqz-image.png" alt="图3"></p></li></ul><hr><h2 id="算法实现">算法实现</h2><p>LeetCode题目<a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a>，这里我直接用优先队列来实现节点的选择，更能说明问题。</p><pre><code class="language-c++">class Solution {public:    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k)     {        vector&lt;int&gt; dis(n + 1, -1);         dis[k] = 0;        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; // 元素递增        pq.push(make_pair(0, k)); // first:距离, second:节点编号        while (!pq.empty()) {            pair&lt;int, int&gt; dst = pq.top();            pq.pop(); // 选取优先队列中第一个节点，即从起点到其他节点路径最短的节点            if (dst.first &gt; dis[dst.second]) { // 当前达到dst的权值比记录的还要大，则不可能是最短路径                continue;            }            for (int i = 0; i &lt; times.size(); i++) {                if (times[i][0] != dst.second) {                    continue;                }                // 遍历以dst为起点的路径                int v = times[i][1];                int w = dst.first + times[i][2];                if (dis[v] == -1 || dis[v] &gt; w) {                    dis[v] = w; // 更新距离                    pq.push(make_pair(w, v));                }            }        }        int ans = 0;        for (int i = 1; i &lt;= n; i++) {            if (dis[i] == - 1) {                return -1;            }            ans = max(ans, dis[i]);        }         return ans;    }};</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Dijkstra算法简介&quot;&gt;Dijkstra算法简介&lt;/h2&gt;
&lt;p&gt;​	Dijkstra算法算是&lt;strong&gt;贪心思想&lt;/strong&gt;实现的，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Dijkstra" scheme="http://example.com/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub 搭建个人博客</title>
    <link href="http://example.com/2021/08/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2021/08/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2021-08-01T15:32:43.000Z</published>
    <updated>2021-08-06T14:42:08.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo-GitHub-搭建个人博客">Hexo + GitHub 搭建个人博客</h2><ul><li><p>安装<code>nodeJs</code>，版本号选择为 <code>v12.14.0</code>，最好选择免安装版本<code>node-v12.14.0-win-x64.zip</code>解压后即可使用</p><p>NodeJs下载地址：<a href="https://nodejs.org/dist/v12.14.0/">https://nodejs.org/dist/v12.14.0/</a>  (注意：免安装版本需要自行添加环境变量)</p></li><li><p>配置<code>npm</code> （<code>nodeJs</code>默认自带<code>npm</code>命令，此步骤可选择，参考链接：<a href="https://www.cnblogs.com/dalyday/p/10664287.html%EF%BC%89">https://www.cnblogs.com/dalyday/p/10664287.html）</a></p><ul><li><p>将<code>npm</code>的默认下载目录从<code>c</code>盘移动到<code>D</code>盘</p><pre><code class="language-shell">npm config set prefix "D:\tool\nodeJs\node_global"npm config set cache "D:\tool\nodeJs\node_cache"</code></pre></li><li><p>配置镜像源，提升速度</p><pre><code class="language-shell">npm config set registry=http://registry.npm.taobao.org</code></pre></li><li><p>查看配置是否成功</p><pre><code class="language-shell">npm config list=====================如下都是回显信息，也可以直接修改C:\Users\xy\.npmrc文件配置===============; cli configsmetrics-registry = "https://registry.npm.taobao.org/"scope = ""user-agent = "npm/6.13.4 node/v12.14.0 win32 x64"; userconfig C:\Users\xy\.npmrccache = "D:\\tool\\nodeJs\\node_cache"prefix = "D:\\tool\\nodeJs\\node_global"registry = "https://registry.npm.taobao.org/"; node bin location = D:\tool\nodeJs\node.exe; cwd = D:\tool; HOME = C:\Users\xy; "npm config ls -l" to show all defaults.</code></pre></li><li><p>由于<code>nodeJs</code>自带的<code>npm</code>不是最新的版本，可以自行升级<code>npm</code>模块</p><pre><code class="language-shell">npm install npm -gnpm -v # 查看npm版本号</code></pre></li><li><p>因为之前修改了<code>npm</code>默认的目录，所以在环境变量<code>PATH</code>中添加<code>D:\tool\nodeJs\node_global</code></p></li></ul></li><li><p>安装 <code>hexo</code></p><pre><code class="language-shell">npm install -g hexo # nodeJs默认自带npm命令</code></pre></li><li><p>选择一个空文件夹作为Blog的根目录，执行初始化，可以自定义下载其他主题</p><pre><code class="language-shell">hexo initgit clone git@github.com:Haojen/hexo-theme-Claudia.git themes/claudia # 下载claudia主题</code></pre></li><li><p>设置<code>NPM</code>淘宝源，安装 <code>CNPM</code></p><pre><code class="language-shell">npm i cnpm -g --registry=http://registry.npm.taobao.org</code></pre></li><li><p>进入<code>Blog</code>根路径安装包</p><pre><code class="language-shell">#必要cnpm install hexo-renderer-pug --savecnpm install hexo-renderer-sass --save cnpm install hexo-generator-search --save cnpm install hexo-deployer-git --save#选择性安装# 如果需要添加订阅功能cnpm install hexo-generator-feed --save # 流程图功能cnpm install hexo-filter-flowchart --save   # Emojicnpm install hexo-filter-github-emojis --save  # 搜索功能cnpm install hexo-generator-search --save   # 数学公式cnpm install hexo-renderer-mathjax --save</code></pre></li><li><p>其他推荐安装包 (可选步骤)</p><ul><li>Hexo中插入<code>mermaid diagrams</code> (<a href="https://blog.csdn.net/Olivia_Vang/article/details/92987859">https://blog.csdn.net/Olivia_Vang/article/details/92987859</a>)</li><li>Hexo中插入本地图片 (<a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a>)</li></ul></li><li><p>配置根目录下的 <code>GitHub</code>项目路径</p><pre><code class="language-shell">deploy:  type: git  repository: git@github.com:xy007man/xy007man.github.io.git  branch: master</code></pre></li></ul><hr><h2 id="参考链接">参考链接</h2><ul><li><p><code>Hexo + GitHub</code> 搭建个人博客：<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p></li><li><p><code>Claudia</code> 主题介绍：<a href="https://github.com/Haojen/hexo-theme-Claudia/blob/master/README-CN.md">https://github.com/Haojen/hexo-theme-Claudia/blob/master/README-CN.md</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hexo-GitHub-搭建个人博客&quot;&gt;Hexo + GitHub 搭建个人博客&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;code&gt;nodeJs&lt;/code&gt;，版本号选择为 &lt;code&gt;v12.14.0&lt;/code&gt;，最好选择免安装版本&lt;code&gt;node-v1</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>内核同步机制：mutex锁</title>
    <link href="http://example.com/2021/07/24/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E9%94%81/"/>
    <id>http://example.com/2021/07/24/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E9%94%81/</id>
    <published>2021-07-24T11:08:58.000Z</published>
    <updated>2021-07-28T14:24:51.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mutex锁的使用">Mutex锁的使用</h2><table><thead><tr><th>函数定义</th><th>功能说明</th></tr></thead><tbody><tr><td>mutex_lock(struct mutex *lock)</td><td>加锁，如果不可用，则睡眠（UNINTERRUPTIBLE）</td></tr><tr><td>mutex_lock_interruptible(struct mutex *lock);</td><td>加锁，如果不可用，则睡眠（TASK_INTERRUPTIBLE）</td></tr><tr><td>mutex_unlock(struct mutex *lock)</td><td>解锁</td></tr><tr><td>mutex_trylock(struct mutex *lock)</td><td>试图获取指定的 mutex，或得到返回1，否则返回 0</td></tr><tr><td>mutex_is_locked(struct mutex *lock)</td><td>如果 mutex 被占用返回1，否则返回 0</td></tr></tbody></table><hr><h2 id="Mutex锁和其他锁的区别">Mutex锁和其他锁的区别</h2><ul><li><code>mutex</code> 一种睡眠锁，其行为和 count 为 1 的信号量类似，但是不同于信号量，<code>mutex</code>需要谁拿的锁谁来释放锁</li><li>不同于自旋锁，mutex临界区允许睡眠</li><li>不同于自旋锁，mutex在拿锁时若锁被别人持有，会根据锁的持有者是否正在运行来决定是乐观自旋或是睡眠等待</li></ul><hr><h2 id="Mutex锁的实现">Mutex锁的实现</h2><ul><li><a href="https://blog.csdn.net/zhoutaopower/article/details/86627438">https://blog.csdn.net/zhoutaopower/article/details/86627438</a></li><li><a href="https://zhuanlan.zhihu.com/p/390107537">https://zhuanlan.zhihu.com/p/390107537</a></li></ul><p>​以上两篇文章介绍的比较好，可以参考看一下，总结一下<code>mutex</code>的特点</p><ul><li><code>mutex</code> 由于性能原因并不是绝对公平调度的，允许偷锁的情况，但是为了相对公平引入了<code>handoff</code>机制，让被偷锁的进程在下次一定可以获取锁。</li><li><code>mutex</code> 锁有自旋锁和信号量的特点，即当持有锁的进程处于执行状态时，等待锁的进程会关闭抢占进行自旋；若持有锁的进程处于睡眠状态时，等待锁的进程也会进行休眠，和信号量的表现一致。</li><li>信号量和<code>mutex</code>锁优选<code>mutex</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mutex锁的使用&quot;&gt;Mutex锁的使用&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数定义&lt;/th&gt;
&lt;th&gt;功能说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;mutex_lock(struct mutex *</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="mutex" scheme="http://example.com/tags/mutex/"/>
    
  </entry>
  
  <entry>
    <title>内核同步机制：信号量</title>
    <link href="http://example.com/2021/07/17/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://example.com/2021/07/17/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E4%BF%A1%E5%8F%B7%E9%87%8F/</id>
    <published>2021-07-17T14:22:32.000Z</published>
    <updated>2021-08-01T15:25:56.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号量的使用">信号量的使用</h2><pre><code class="language-c">struct semaphore {raw_spinlock_tlock;unsigned intcount;struct list_headwait_list;};void sema_init(struct semaphore *sem, int val);void down(struct semaphore *sem);int down_interruptible(struct semaphore *sem); // 在睡眠期间可以被信号打断返回void up(struct semaphore *sem)</code></pre><hr><h2 id="源码分析">源码分析</h2><pre><code class="language-c">void down(struct semaphore *sem){unsigned long flags;raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);if (likely(sem-&gt;count &gt; 0)) // 对应sema_init中的第二个参数val，如果当前大于0，当前进程可以进入临界区执行sem-&gt;count--;else__down(sem); // 否则将将当前进程阻塞住raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);}// down 最终会调用到 __down_commonstatic inline int __sched __down_common(struct semaphore *sem, long state,long timeout){struct semaphore_waiter waiter;list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list); // 将当前进程加入等待链表中waiter.task = current; // current 代表当前进程的结构体waiter.up = false;for (;;) {if (signal_pending_state(state, current)) // 如果当前进程有信号处理，则返回-EINTRgoto interrupted;if (unlikely(timeout &lt;= 0))goto timed_out;__set_current_state(state); // 设置当前进程状态(TASK_INTERRUPTIBLE/TASK_UNINTERRUPTIBLE)raw_spin_unlock_irq(&amp;sem-&gt;lock);timeout = schedule_timeout(timeout); // 主动退出调度，进入此函数后进程已经成功阻塞住了，等待被唤醒raw_spin_lock_irq(&amp;sem-&gt;lock); if (waiter.up)return 0;} timed_out:list_del(&amp;waiter.list);return -ETIME; interrupted:list_del(&amp;waiter.list);return -EINTR;}void up(struct semaphore *sem){unsigned long flags;raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);if (likely(list_empty(&amp;sem-&gt;wait_list))) // 当前没有任何进程阻塞在该信号量上sem-&gt;count++;else__up(sem);raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);}static noinline void __sched __up(struct semaphore *sem){struct semaphore_waiter *waiter = list_first_entry(&amp;sem-&gt;wait_list,struct semaphore_waiter, list); // 获取第一个阻塞在此信号量上的进程list_del(&amp;waiter-&gt;list);waiter-&gt;up = true;wake_up_process(waiter-&gt;task); // 唤醒进程}</code></pre><h2 id="总结">总结</h2><p>​可以看到Linux内核中信号量的使用和实现都是十分简洁的。可以看出内核中用一条链表实现了阻塞在信号量上多个进程的公平调度，不过从内核中的实现来看貌似这并不是最优的实现，因为临界区代码往往都比较短小，但是如果进程获取不到信号量就会直接睡眠下去，这可能会造成进程频繁的睡眠唤醒。下一节会分析一下内核中 <code>mutex</code> 的实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信号量的使用&quot;&gt;信号量的使用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct semaphore {
	raw_spinlock_t		lock;
	unsigned int		count;
	struct list_head	</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="信号量" scheme="http://example.com/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>编程银弹</title>
    <link href="http://example.com/2021/07/10/%E7%BC%96%E7%A8%8B%E9%93%B6%E5%BC%B9/"/>
    <id>http://example.com/2021/07/10/%E7%BC%96%E7%A8%8B%E9%93%B6%E5%BC%B9/</id>
    <published>2021-07-10T08:59:52.000Z</published>
    <updated>2021-08-01T15:24:52.146Z</updated>
    
    <content type="html"><![CDATA[<h1>小白</h1><p>记得在大一刚接触编程时，经常陷入语法的陷阱，把大部分精力放在了学习语法上，经常因为知道了语言上的一些奇技淫巧而沾沾自喜。大一实验课设计一个的图书管理系统，代码删删改改，磕磕碰碰最后勉强跑通，感觉费了好多脑细胞。时常听到编程语言只是工具，好的代码是给人看的，好的代码需要好的设计。之后学习了软件工程、接触了23种设计模式，但是仍然懵懵懂懂，经常在想编程到底有没有银弹。</p><span id="more"></span><hr><h1>工作</h1><p>工作之后，部门潇潇洒洒规定了百八十条的编程规范让新员工记住。印象比较深的就是一个函数不要超过50行。其实在刚开始我也没觉的有啥坏处，按照规定来就行了。之后就出现了各种牛鬼蛇神的代码，许多代码明明放在一个函数逻辑比较通顺，为了符合编程规范必须拆分成2个甚至3个函数。</p><hr><h1>思考</h1><p>一个函数超过50行就是烂代码吗？显然不是这样。我也写了几年代码，自己有一点感触。当你要设计一个类或者函数时，第一要<strong>先明确</strong>函数的功能，明确好入参和出参**。新手时常陷入其中细节的逻辑中，缺啥参数返回头在去增加，修改来修改去，最终成型的代码，参数可能有5、6个，临时变量7、8个，函数行数膨胀到2~3百行。第二在写具体逻辑的时候，<strong>如果发现你的脑细胞不够用的，一定要意识到你应该</strong>再封装一个函数了**。你自己写的代码你应该最清楚业务逻辑，但是你自己写的时候都费劲，如果这样的业务代码交给别人去review或者维护那将是一个灾难。一般一个函数代码行数不应该超过一屏半，最好不要超过150行，但是代码行不应该做为判断代码好坏的绝对条件。</p><p>最后回到主题编程有银弹吗？我认为是没有的，不能靠条条框框的编程规范去让程序员写出更好的代码。靠编程规范约束的开发人员不会是一个好的开发人员，他已经被这些条条框框约束住了，缺失了创造力。大家最不愿意做的是啥？就是写设计文档，说白了就是不愿意思考，如果模块的接口定义好了，其实剩下的就是搬砖了。不否定编程规范对新手的积极作用，但是作为一位老鸟应该明白其中的门道。希望有一天我也能像卖油翁那样说一句：“无他，唯手熟尔”。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h1&gt;小白&lt;/h1&gt;
&lt;p&gt;记得在大一刚接触编程时，经常陷入语法的陷阱，把大部分精力放在了学习语法上，经常因为知道了语言上的一些奇技淫巧而沾沾自喜。大一实验课设计一个的图书管理系统，代码删删改改，磕磕碰碰最后勉强跑通，感觉费了好多脑细胞。时常听到编程语言只是工具，好的代码是给人看的，好的代码需要好的设计。之后学习了软件工程、接触了23种设计模式，但是仍然懵懵懂懂，经常在想编程到底有没有银弹。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS基本原理简析</title>
    <link href="http://example.com/2021/07/03/HTTPS/"/>
    <id>http://example.com/2021/07/03/HTTPS/</id>
    <published>2021-07-03T14:32:50.000Z</published>
    <updated>2021-08-06T14:42:18.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础">基础</h2><ul><li><p>对称加密算法</p><p>对称加密算法的特点是加密密钥和解密密钥是同一把密钥K，且加解密速度快，典型的对称加密算法有DES、AES等</p><p><img src="/2021/07/03/HTTPS/548912-20160303105320549-487055351.png" alt="对称加密算法加密流程和解密流程"></p></li><li><p>非对称加密算法</p><p>​非对称加密算法的特点是加密密钥K1和解密密钥K2是不一样的，他们是一对可互为加解密的密钥，一个可以公开，叫公钥；一个自己保留，不能让其他人知道，叫私钥。这样就能比较好的解决信息传递的安全性，相对来说加解密速度较慢，典型的非对称加密算法有RSA、DSA等。</p><p><img src="/2021/07/03/HTTPS/548912-20160303111011190-1826727713.png" alt="非对称加密算法加密流程和解密流程"></p></li></ul><hr><h2 id="非对称加密的两大应用">非对称加密的两大应用</h2><ul><li><p>加密通信：公钥加密，私钥解密</p></li><li><p>数字签名：私钥加密，公钥解密</p><ul><li><p>发送方（甲方）签名过程：使用单向哈希算法对明文生成摘要，用私钥将摘要加密</p><p><img src="/2021/07/03/HTTPS/548912-20160303111013487-1921207550.png" alt="摘要算法及数字签名过程"></p></li><li><p>接收方（乙方）校验过程：接受方把接收到的发送方的明文用单向哈希函数取得摘要值与发送方的公钥解密发送方的数字签名而得到的摘要值进行比较，如果一样说明信息完整，未受篡改，如果不一样说明受到篡改。</p><p><img src="/2021/07/03/HTTPS/548912-20160303111014549-473199446.png" alt="检验数据完整性过程"></p></li></ul></li></ul><hr><h2 id="HTTPS的工作方式">HTTPS的工作方式</h2><p>​<code>HTTPS</code> 实际采用的是混合加密的方式，即通过<strong>非对称加密的方式传递对称加密的密钥，对称加密的方式传递主体数据</strong>，通过<strong>检查证书是不是由可以信赖的机构颁发的，确认证书有效和此证书是此网站的，即检查公钥的合法性</strong>。</p><p><img src="/2021/07/03/HTTPS/548912-20160303111014549-47319944.png" alt="HTTPS工作方式"></p><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://www.cnblogs.com/gordon0918/p/5237717.html">https://www.cnblogs.com/gordon0918/p/5237717.html</a></p></li><li><p><a href="https://www.cnblogs.com/wang-yaz/p/10604403.html">https://www.cnblogs.com/wang-yaz/p/10604403.html</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础&quot;&gt;基础&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对称加密算法&lt;/p&gt;
&lt;p&gt;对称加密算法的特点是加密密钥和解密密钥是同一把密钥K，且加解密速度快，典型的对称加密算法有DES、AES等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/07/03/HTTPS/5489</summary>
      
    
    
    
    <category term="https" scheme="http://example.com/categories/https/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>字节序/比特序</title>
    <link href="http://example.com/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/"/>
    <id>http://example.com/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/</id>
    <published>2021-07-01T14:52:41.000Z</published>
    <updated>2021-08-06T14:41:05.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大端序-小端序">大端序/小端序</h2><p>​字节序即字节的存储顺序，如果数据都是单字节的，那怎么存储无所谓了，但是对于多字节数据，比如int，double等，就要考虑存储的顺序了。字节序是硬件层面的东西，通常只和你使用的处理器架构有关，而和编程语言无关。字节序分为大端序和小端序。</p><ul><li><p><strong>大端序</strong>：<strong>将高序字节存储在起始地址</strong>，一个占有4个字节类型的数据0x00112233在内存中如下分布：</p><p><img src="/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/19d498caac5304a2faedd537c5544d87.png" alt="大端模式"></p></li><li><p><strong>小端序</strong>：<strong>将低序字节存储在起始地址</strong>，数据0x00112233在内存中如下分布：</p><p><img src="/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/664881c6233ab0ed63cddc96db08afbc.png" alt="小端模式"></p><hr><h2 id="比特序-位域">比特序/位域</h2><p>​位域的写入顺序和当前系统字节序有关：先定义的位域在大端环境从最高bit位(<code>MSB</code>)开始分配。如果为小端环境则先定义的位域从最低bit位（<code>LSB</code>）开始分配。(CPU操作内存还是以字节为单位的)</p><pre><code class="language-c">struct bitfield{    uint8_t a:1;    uint8_t b:2;    uint8_t c:3;    uint8_t d:2;}bf;bf.a = 1;bf.b = 2;bf.c = 3;bf.d = 3;</code></pre></li><li><p>大端系统：<code>struct bitfield bf</code> 在内存中如下分布：</p><p><img src="/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/5dad1350789a2397a4830e8c4d4d322a.png" alt="MSB"></p></li><li><p>小端系统：<code>struct bitfield bf</code> 在内存中如下分布：</p></li></ul><p><img src="/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/4c5e9f8058a75efa50022165f273e476.png" alt="LSB"></p><p>​比特的发送、接收顺序对CPU、软件都是不可见的，（对诸如PHY的serdes(串行器和解串器)以及网卡写总线的硬件设计是非常重要的）因为我们的网卡会给我们处理这种转换，在发送的时候按照小端序发送比特位，<strong>在接收的时候网卡会把接收到的比特序转换成主机的比特序</strong>，下面是一个小端机器发送一个int整型给一个大端机器的示意图：</p><p>​<img src="/2021/07/01/%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%BA%8F%E4%B8%BB%E6%9C%BA%E5%BA%8F/20171222210949014" alt="bit网络发送"></p><p>​因为不同的平台的比特序是不同的，但是我们定义的位域需要根据平台的大小端进行转换，以iphdr为例：</p><pre><code class="language-c">struct iphdr {#if defined(__LITTLE_ENDIAN_BITFIELD)        __u8    ihl:4,                version:4;#elif defined (__BIG_ENDIAN_BITFIELD)        __u8    version:4,                ihl:4;#else#error  "Please fix &lt;asm/byteorder.h&gt;"#endif        __u8    tos;        __u16   tot_len;        __u16   id;        __u16   frag_off;        __u8    ttl;        __u8    protocol;        __u16   check;        __u32   saddr;        __u32   daddr;        /*The options start here. */};</code></pre><hr><h2 id="网络序-主机序">网络序/主机序</h2><ul><li>网络序：采用大端的排序方式</li><li>主机序：不同的CPU有不同的字节序类型这些字节序是指整数在内存中保存的顺序，CPU上运行不同的操作系统，字节序也是不同的</li></ul><table><thead><tr><th>处理器</th><th>操作系统</th><th>字节排序</th></tr></thead><tbody><tr><td>Alpha</td><td>全部</td><td>Little endian</td></tr><tr><td>HP-PA</td><td>NT</td><td>Little endian</td></tr><tr><td>HP-PA</td><td>UNIX</td><td>Big endian</td></tr><tr><td>Intelx86</td><td>全部</td><td>Little endian</td></tr><tr><td>Motorola680x</td><td>全部</td><td>Big endian</td></tr><tr><td>MIPS</td><td>NT</td><td>Little endian</td></tr><tr><td>MIPS</td><td>UNIX</td><td>Big endian</td></tr><tr><td>PowerPC</td><td>NT</td><td>Little endian</td></tr><tr><td>PowerPC</td><td>非NT</td><td>Big endian</td></tr><tr><td>RS/6000</td><td>UNIX</td><td>Big endian</td></tr><tr><td>SPARC</td><td>UNIX</td><td>Big endian</td></tr><tr><td>IXP1200 ARM核心</td><td>全部</td><td>Little endian</td></tr></tbody></table><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://blog.csdn.net/firefly_2002/article/details/8034046">https://blog.csdn.net/firefly_2002/article/details/8034046</a></p></li><li><p><a href="https://blog.csdn.net/qq_34907757/article/details/117670413">https://blog.csdn.net/qq_34907757/article/details/117670413</a></p></li><li><p><a href="https://blog.csdn.net/godleading/article/details/78876639">https://blog.csdn.net/godleading/article/details/78876639</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;大端序-小端序&quot;&gt;大端序/小端序&lt;/h2&gt;
&lt;p&gt;​	字节序即字节的存储顺序，如果数据都是单字节的，那怎么存储无所谓了，但是对于多字节数据，比如int，double等，就要考虑存储的顺序了。字节序是硬件层面的东西，通常只和你使用的处理器架构有关，而和编程语言无关。</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="字节序" scheme="http://example.com/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Linux字符设备驱动与杂项设备驱动</title>
    <link href="http://example.com/2021/06/27/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8_%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <id>http://example.com/2021/06/27/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8_%E6%9D%82%E9%A1%B9%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</id>
    <published>2021-06-27T11:35:33.000Z</published>
    <updated>2021-08-01T14:31:38.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符设备驱动">字符设备驱动</h2><pre class="mermaid">graph LRA[字符设备驱动框架]--&gt;B1[驱动初始化]B1[驱动初始化]--&gt;C1[分配设备号]C1[分配设备号]--&gt;D1[静态分配设备号]D1[静态分配设备号]--&gt;E(register_chrdev_region)C1[分配设备号]--&gt;D2[动态分配设备号]D2[动态分配设备号]--&gt;F(alloc_chrdev_region)C1[分配设备号]--&gt;D3[操作设备号dev_t]D3[操作设备号dev_t]--&gt;Z1(MAJOR提取主设备号)D3[操作设备号dev_t]--&gt;Z2(MINOR提取主设备号)D3[操作设备号dev_t]--&gt;Z3(MKDRV将主次设备号合成dev_t)D3[操作设备号dev_t]--&gt;Z4(cat /proc/device/xxx查看设备号)B1[驱动初始化]--&gt;C2[初始化cdev]C2[初始化cdev]--&gt;G(cdev_init)B1[驱动初始化]--&gt;C3[注册cdev]C3[注册cdev]--&gt;H(cdev_add)A[字符设备驱动框架]--&gt;B2[构建file_operations]B2[构建file_operations]--&gt;J1(open)B2[构建file_operations]--&gt;J2(read)J2(read)--&gt;K(copy_to_user)B2[构建file_operations]--&gt;J3(write)J3(write)--&gt;L(copy_from_user)B2[构建file_operations]--&gt;J4(ioctl)J4(ioctl)--&gt;M(copy_from_user/copy_to_user)B2[构建file_operations]--&gt;J5(close)A[字符设备驱动框架]--&gt;B3[生成设备节点]B3[生成设备节点]--&gt;N1[手动生成设备节点]N1[手动生成设备节点]--&gt;O(mknod命令)B3[生成设备节点]--&gt;N2[自动生成设备节点]N2[自动生成设备节点]--&gt;M1(class_create:在/sys/class/目录下创建一个class)N2[自动生成设备节点]--&gt;M2(device_create:在/dev/目录下创建一个device)A[字符设备驱动框架]--&gt;B4[驱动卸载]B4[驱动卸载]--&gt;P1[释放设备号]P1[释放设备号]--&gt;Q(unregister_chrdev_region)B4[驱动卸载]--&gt;P2[卸载cdev]P2[卸载cdev]--&gt;R(cdev_del)B4[驱动卸载]--&gt;P3[卸载设备]P3[卸载设备]--&gt;T(device_destory)</pre><hr><h2 id="杂项设备驱动">杂项设备驱动</h2><pre class="mermaid">graph LRA[杂项设备驱动框架]--&gt;B1[注册杂项设备]B1[注册杂项设备]--&gt;C(misc_register)A[杂项设备驱动框架]--&gt;B2[构建杂项设备结构体]B2[构建杂项设备结构体]--&gt;D(struct miscdevice:对次设备号/设备节点名称/file_operations初始化)A[杂项设备驱动框架]--&gt;B3[构建file_operations]B3[构建file_operations]--&gt;J1(open)B3[构建file_operations]--&gt;J2(read)J2(read)--&gt;K(copy_to_user)B3[构建file_operations]--&gt;J3(write)J3(write)--&gt;L(copy_from_user)B3[构建file_operations]--&gt;J4(ioctl)J4(ioctl)--&gt;M(copy_from_user/copy_to_user)B3[构建file_operations]--&gt;J5(close)A[杂项设备驱动框架]--&gt;B4[卸载杂项设备]B4[卸载杂项设备]--&gt;E(misc_deregister)</pre><hr><h2 id="应用层打开节点">应用层打开节点</h2><pre class="mermaid">graph LRA[应用程序]--&gt;B1[open]B1--&gt;C[file_operations]A[应用程序]--&gt;B2[read]B2--&gt;C[file_operations]A[应用程序]--&gt;B3[write]B3--&gt;C[file_operations]A[应用程序]--&gt;B4[ioctl]B4--&gt;C[file_operations]A[应用程序]--&gt;B5[close]B5--&gt;C[file_operations]C--&gt;D1[内核注册的open]C--&gt;D2[内核注册的read]C--&gt;D3[内核注册的write]C--&gt;D4[内核注册的ioctl]C--&gt;D5[内核注册的close]D1--&gt;E[操作硬件]D2--&gt;E[操作硬件]D3--&gt;E[操作硬件]D4--&gt;E[操作硬件]D5--&gt;E[操作硬件]</pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符设备驱动&quot;&gt;字符设备驱动&lt;/h2&gt;
&lt;pre class=&quot;mermaid&quot;&gt;graph LR
A[字符设备驱动框架]--&amp;gt;B1[驱动初始化]
	B1[驱动初始化]--&amp;gt;C1[分配设备号]
		C1[分配设备号]--&amp;gt;D1[静态分配设备号]
</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="驱动" scheme="http://example.com/tags/%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>人机对弈</title>
    <link href="http://example.com/2021/06/26/%E4%BA%BA%E6%9C%BA%E5%AF%B9%E5%BC%88/"/>
    <id>http://example.com/2021/06/26/%E4%BA%BA%E6%9C%BA%E5%AF%B9%E5%BC%88/</id>
    <published>2021-06-26T13:29:06.000Z</published>
    <updated>2021-08-06T14:41:52.268Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景">背景</h2><p>​小时候在FC上玩过象棋游戏，印象最深的就是那个老头，每次走棋贼慢同时棋力也特高。一直想了解下人机对弈的算法，看了几篇文章后，发现基本的套路都是一样的，自己写了一个小时候玩的<code>两口吃一口</code>的小游戏。</p><img src="/2021/06/26/%E4%BA%BA%E6%9C%BA%E5%AF%B9%E5%BC%88/FC象棋.jpg" alt="FC象棋" style="zoom:50%;"><hr><h2 id="棋类AI基本步骤-以下都是基于两口吃一口这个小游戏">棋类AI基本步骤(以下都是基于<code>两口吃一口</code>这个小游戏)</h2><ul><li><p><strong>局面生成</strong>：棋子种类、开局位置</p><pre><code class="language-c++">// 5x5 棋盘，黑方和白方初始时都有5颗棋子/*  0 1 2 3 4 ┌─────────┐0│○─○─○─○─○│1│├─┼─┼─┼─┤│2│├─┼─┼─┼─┤│3│├─┼─┼─┼─┤│4│●─●─●─●─●│ └─────────┘ */std::string GenBoard(int row, int col, int colNum, int rowNum, std::map&lt;std::pair&lt;int, int&gt;, int&gt; board){std::string str;auto it = board.find(std::make_pair(row, col));if (it != board.end()) {if (it-&gt;second == WHITE) {return "○";}if (it-&gt;second == BLACK) {return "●";}}if (row == 0 &amp;&amp; col == 0) {str = "┌";}else if (row == 0 &amp;&amp; col == colNum - 1) {str = "┐";}else if (row == rowNum - 1 &amp;&amp; col == 0) {str = "└";}else if (row == rowNum - 1 &amp;&amp; col == colNum - 1) {str = "┘";}else if (row == 0) {str = "┬";}else if (col == colNum - 1) {str = "┤";}else if (col == 0) {str = "├";}else if (row == rowNum - 1) {str = "┴";}else {str = "┼";}return str;}// 棋盘绘制void DrawBoard(){std::string posCol;std::string topBorderLine;std::string bottomBorderLine;posCol += "  ";for (int i = 0; i &lt; g_colNum; i++) {posCol += std::to_string(i) + " ";}GenBorderLine(topBorderLine, bottomBorderLine, g_colNum);std::cout &lt;&lt; posCol &lt;&lt; std::endl;std::cout &lt;&lt; topBorderLine &lt;&lt; std::endl;for (int rowIdx = 0; rowIdx &lt; g_rowNum; rowIdx++) {std::cout &lt;&lt; std::to_string(rowIdx) &lt;&lt; "│";for (int colIdx = 0; colIdx &lt; g_colNum; colIdx++) {std::cout &lt;&lt; GenBoard(rowIdx, colIdx, g_rowNum, g_colNum, g_board);if (colIdx != g_colNum - 1) {std::cout &lt;&lt; "─";}}std::cout &lt;&lt; "│" &lt;&lt; std::endl;}std::cout &lt;&lt; bottomBorderLine &lt;&lt; std::endl;}</code></pre></li><li><p><strong>走法生成</strong>：走棋规则、吃子规则、胜利规则</p><pre><code class="language-c++">// 上下左右不超出棋盘并且目标位置没有棋子void GenMoveWays(int player, std::vector&lt;std::tuple&lt;int, int, int, int&gt;&gt;&amp; ways){int direct[4][2] = { {0, 1}, {1, 0}, {0, -1}, {-1, 0} };for (auto &amp;i : g_board) {if (i.second != player) {continue;}for (int k = 0; k &lt; 4; k++) {int nextRow = i.first.first + direct[k][0];int nextCol = i.first.second + direct[k][1];if (CheckPostion(nextRow, nextCol)) {continue;}auto nextIt = g_board.find(std::make_pair(nextRow, nextCol));if (nextIt != g_board.end()) {continue;}ways.push_back(std::make_tuple(i.first.first, i.first.second, nextRow, nextCol));}}}/* 一行或者一列两个连续己方棋子可以吃对方一个棋子 _○○●_：OK ○○●__：OK __○○●：OK ○○●_●：这种情况不能吃子 ○○○●_：这种情况不能吃子 _○○○●：这种情况不能吃子 _●○○●：这种情况不能吃子 ●○○●_：这种情况不能吃子*/int GetPieceNumByDirect(int row, int col, int direct[2]){int pieceNum = 0;if (direct[0] != 0 &amp;&amp; direct[1] != 0) {std::cout &lt;&lt; "错误的方向" &lt;&lt; std::endl;assert(0);return 0;}if (direct[0] != 0) {for (int i = 0; i &lt; g_rowNum; i++) {auto it = g_board.find(std::make_pair(i, col));if (it != g_board.end()) {pieceNum++;}}return pieceNum;}for (int i = 0; i &lt; g_colNum; i++) {auto it = g_board.find(std::make_pair(row, i));if (it != g_board.end()) {pieceNum++;}}return pieceNum;}// 当前走棋方棋子数量小于2，则为失败（连续两个棋子才能吃对方一个棋子）bool IsCurrentPlayLose(){return GetPieceNum(g_currentPlayer) &lt; 2;}</code></pre></li><li><p><strong>局面评估</strong>：这部分其实是大多棋类AI的关键，别看我写的局面评估只有一个语句</p><pre><code class="language-c++">// 己方棋子越多，对自己越有利int EvaluatePosition(){return GetPieceNum(WHITE) - GetPieceNum(BLACK);}</code></pre></li><li><p><strong>局面搜索</strong>：搜索算法要和评估函数结合，通过好的剪枝算法会大大提高AI的智慧，我这里就是一个简单极大极小值深度优先搜索</p><pre><code class="language-c++">int GenOneStep(int fromRow, int fromCol, int toRow, int toCol, std::vector&lt;std::pair&lt;int, int&gt;&gt; &amp;eats){std::set&lt;std::tuple&lt;int, int, int, int&gt;&gt; ways;if (!IsVaildPiece(fromRow, fromCol, toRow, toCol, g_currentPlayer)) {return -1;}// 走一步棋DeletePiece(fromRow, fromCol, g_currentPlayer);AddPiece(toRow, toCol, g_currentPlayer);// 吃子EatPiece(toRow, toCol, g_currentPlayer, eats);// 交换走棋方ChangePlayer();//DrawBoard();return 0;}void UndoOneStep(int fromRow, int fromCol, int toRow, int toCol, std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; eats){// 还原被吃掉的对方棋子for (auto&amp; i : eats) {AddPiece(i.first, i.second, g_currentPlayer); // 当前走棋方为对方}eats.clear();// 交换走棋方ChangePlayer();// 撤销上一步棋DeletePiece(toRow, toCol, g_currentPlayer);AddPiece(fromRow, fromCol, g_currentPlayer);}int Search(int depth, int&amp; fromRow, int&amp; fromCol, int &amp;toRow, int &amp;toCol){int bestValue;int value;if (depth == 0) {return EvaluatePosition();}if (g_currentPlayer == BLACK) {bestValue = INFINITY_VALUE;  // bestValue越小对黑方越有利}else {bestValue = -INFINITY_VALUE; // bestValue越大对白方越有利}std::vector&lt;std::tuple&lt;int, int, int, int&gt;&gt; ways;std::vector&lt;std::pair&lt;int, int&gt;&gt; eats;GenMoveWays(g_currentPlayer, ways);for (auto&amp; i : ways) {if (GenOneStep(std::get&lt;0&gt;(i), std::get&lt;1&gt;(i), std::get&lt;2&gt;(i), std::get&lt;3&gt;(i), eats)) {continue;}value = Search(depth - 1, fromRow, fromCol, toRow, toCol);UndoOneStep(std::get&lt;0&gt;(i), std::get&lt;1&gt;(i), std::get&lt;2&gt;(i), std::get&lt;3&gt;(i), eats);if (g_currentPlayer == BLACK) {if (value &lt; bestValue) {bestValue = value;if (depth == MAX_SEARCH_DEPTH) {fromRow = std::get&lt;0&gt;(i);fromCol = std::get&lt;1&gt;(i);toRow = std::get&lt;2&gt;(i);toCol = std::get&lt;3&gt;(i);}}}else {if (value &gt; bestValue) {bestValue = value;if (depth == MAX_SEARCH_DEPTH) {fromRow = std::get&lt;0&gt;(i);fromCol = std::get&lt;1&gt;(i);toRow = std::get&lt;2&gt;(i);toCol = std::get&lt;3&gt;(i);}}}}// 当前方已经无棋可走了if (g_currentPlayer == BLACK &amp;&amp; bestValue == INFINITY_VALUE) {// 黑方value越小越好，即搜索深度越深到达无路可走越好return INFINITY_VALUE - (MAX_SEARCH_DEPTH - depth);}if (g_currentPlayer == WHITE &amp;&amp; bestValue == -INFINITY_VALUE) {return (MAX_SEARCH_DEPTH - depth) - INFINITY_VALUE;}return bestValue;}void ComputerOneStep(){int fromRow;int fromCol;int toRow; int toCol;std::vector&lt;std::pair&lt;int, int&gt;&gt; eats;Search(MAX_SEARCH_DEPTH, fromRow, fromCol, toRow, toCol);GenOneStep(fromRow, fromCol, toRow, toCol, eats);}</code></pre></li></ul><hr><h2 id="项目链接">项目链接</h2><p><a href="https://github.com/xy007man/2KouChiYiKou">https://github.com/xy007man/2KouChiYiKou</a></p><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://www.zhihu.com/question/34816738">https://www.zhihu.com/question/34816738</a></p></li><li><p><a href="https://www.xqbase.com/computer.htm">https://www.xqbase.com/computer.htm</a></p></li><li><p><a href="https://www.zhihu.com/question/29472711/answer/45436565">https://www.zhihu.com/question/29472711/answer/45436565</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;​	小时候在FC上玩过象棋游戏，印象最深的就是那个老头，每次走棋贼慢同时棋力也特高。一直想了解下人机对弈的算法，看了几篇文章后，发现基本的套路都是一样的，自己写了一个小时候玩的&lt;code&gt;两口吃一口&lt;/code&gt;的小游戏。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="极大极小值" scheme="http://example.com/tags/%E6%9E%81%E5%A4%A7%E6%9E%81%E5%B0%8F%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>踩内存</title>
    <link href="http://example.com/2021/06/22/%E8%B8%A9%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/2021/06/22/%E8%B8%A9%E5%86%85%E5%AD%98/</id>
    <published>2021-06-22T13:38:06.000Z</published>
    <updated>2021-08-07T13:05:47.929Z</updated>
    
    <content type="html"><![CDATA[<p>​对于C/C++程序员来说，踩内存问题是最难分析定位的，往往问题的源头都比较隐蔽，让人很难排查出问题的根源所在。</p><span id="more"></span><hr><h2 id="原因">原因</h2><ul><li><p>内存越界</p><ol><li><code>memset/memcpy/memmove</code> 等内存操作函数操作越界，使用这些函数时尽可能用 <code>memset_s/memcpy_s/memmove_s</code> 等安全函数替代。</li><li>内存越界的问题有个显著的特点，被踩的内存是连续的，遇到这种情况首先怀疑在被踩内存前面申请的内存的操作是否越界。</li></ol></li><li><p>数组越界/操作字符串越界</p><p>数组越界访问往往是最常见的踩内存原因，对于数组访问一定要先判断下标是否越界</p></li><li><p>野指针</p><ol><li>对于全局的变量在释放内存后一定要置为NULL，防止出现野指针</li><li>警惕浅拷贝潜在的野指针风险。浅拷贝只是拷贝了它在栈中存储的指针，它们指向的都是同一个堆内存地址，所以浅拷贝在某些情况会造成改变数据后导致别的另一份数据也同步被改变的情况；而深拷贝是直接将堆内存中存储的数据直接复制一份，不会有浅拷贝互相影响的问题。</li><li>某些时候查看 <code>coredump</code> 现场发现程序访问的地址非常小，首先怀疑空指针。因为结构体的基地址是0，程序在访问结构体成员时会进行若干字节的偏移，所以最终挂死的现场的地址非常小。</li></ol></li><li><p>多线程场景下，全局资源未作加锁保护</p><p>这种情况可能更加复杂，需要对代码进行深度检视</p></li></ul><hr><h2 id="常用定位手段">常用定位手段</h2><ul><li><p>使用系统提供的函数修改内存为只读属性，发生踩内存时程序会直接崩溃，查看相关 <code>coredump</code> 文件进行分析定位</p><ol><li><p>用户态进程：<code>mprotect</code></p><pre><code class="language-c">#include &lt;unistd.h&gt;#include &lt;sys/mmap.h&gt;int mprotect(const void *start, size_t len, int prot);</code></pre><p>函数使用方法参考：<a href="https://www.cnblogs.com/ims-/p/13222243.html">https://www.cnblogs.com/ims-/p/13222243.html</a></p></li><li><p>内核：<code>set_mem_rw</code></p><pre><code class="language-c">#include &lt;linux/kallsyms.h&gt;int set_mem_rw(unsigned long ,int)set_mem_rw = (void *)kallsyms_lookup_name("set_memory_rw"); // 这个函数内核并未导出，不能直接调用</code></pre></li></ol></li><li><p>valgrind 工具分析</p><p>valgrind是一个强大的内存管理工具，常用来检测内存泄漏和内存的非法使用</p><p>具体使用方法参考：<a href="https://blog.csdn.net/weixin_29666341/article/details/116637397">https://blog.csdn.net/weixin_29666341/article/details/116637397</a></p></li><li><p><code>GCC</code> 栈保护机制 <code>stack-protector</code></p><p>程序执行栈内存被踩，程序崩溃的位置是不确定的，为了使崩溃的地点更加接近问题点，可以在编译时加入相关编译选项</p><p>具体使用方法参考：<a href="https://www.cnblogs.com/arnoldlu/p/11630979.html">https://www.cnblogs.com/arnoldlu/p/11630979.html</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	对于C/C++程序员来说，踩内存问题是最难分析定位的，往往问题的源头都比较隐蔽，让人很难排查出问题的根源所在。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="问题定位" scheme="http://example.com/tags/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>反向代理和正向代理</title>
    <link href="http://example.com/2021/06/21/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2021/06/21/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/</id>
    <published>2021-06-21T14:28:04.000Z</published>
    <updated>2021-08-06T14:41:23.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代理">代理</h2><p>​代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。刚开始的时候，代理多数是帮助内网client访问外网server用的后来出现了反向代理，"反向"这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求转发到内网服务器，从外到内。</p><hr><h2 id="正向代理">正向代理</h2><p>​正向代理类似一个跳板机，代理访问外部资源比如我们国内访问谷歌，直接访问访问不到，我们可以通过一个正向代理服务器，请求发到代理服，代理服务器能够访问谷歌，这样由代理去谷歌取到返回数据，再返回给我们，这样我们就能访问谷歌了。</p><p><img src="/2021/06/21/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86.png" alt="正向代理"></p><p><strong>正向代理的用途：</strong></p><ul><li><p>访问原来无法访问的资源，如google</p></li><li><p>可以做缓存，加速访问资源</p></li><li><p>对客户端访问授权，上网进行认证</p></li><li><p>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p></li></ul><hr><h2 id="反向代理">反向代理</h2><p>​反向代理（Reverse Proxy）实际运行方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。反向代理一般就是指Nginx，是在主服务器之外加一层代理服务器，用户的请求会发送到代理服务器上，由代理服务器请求真正的服务器，获得到结果后再将结果返回给用户。</p><p><img src="/2021/06/21/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.png" alt="反向代理"></p><p><strong>反向代理的作用：</strong></p><ul><li><p>保证内网的安全，阻止web攻击，大型网站，通常将反向代理作为公网访问地址，Web服务器是内网</p></li><li><p>负载均衡，通过反向代理服务器来优化网站的负载</p></li></ul><hr><h2 id="CDN">CDN</h2><p>​CDN是内容分发网络（Content Delivery Network）。是为了解决用户请求响应过慢的问题。比如用户在黑龙江，服务器在海南，用户请求的速度可能受距离、带宽的影响。CDN将几台机器分发在全国各地，用户发出的请求会选择就近的CDN服务器进行处理。CDN简单的来说就是存储一些静态文件的一台或多台服务器，通过复制，缓存主服务器等方式，将文件保存其中。</p><p><img src="/2021/06/21/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86/CDN.jpg" alt="CDN"></p><p><strong>CDN作用：</strong></p><ul><li>CDN作用和反向代理相同，一方面加快用户访问速度，另一方面也减轻了后端服务器的负载压力</li></ul><p><strong>CDN和反向代理的区别：</strong></p><ul><li>CDN和反向代理的基本原理都是缓存，区别在于CDN部署在网络提供商的机房，使用户在请求网站服务时，可以从距离自己最近的网络提供商机房获取数据。</li><li>反向代理则部署在网站的中心机房，当用户请求到达中心机房后，首先访问的服务器反向代理服务器，如果反向代理服务器中缓存着用户请求的资源，就将其直接返回给用户。</li></ul><hr><h2 id="应用">应用</h2><p><strong>正向代理</strong>：</p><ul><li><p>许多科学上网的软件如SS、SSR、v2ray原理上都是正向代理，可以参考：</p><p><a href="https://github.com/xiaoming2028/FreePAC">v2ray搭建教程</a><br><a href="https://github.com/233boy/v2ray">v2ray安装脚本</a></p></li></ul><p><strong>反向代理/CDN：</strong></p><ul><li><p><a href="https://www.cloudflare.com/zh-cn/">cloudfare</a> 是国外一家CDN服务商，对于个人用户提供了一些免费的服务，可以把自己的网址托管在 <code>cloudfare</code> 上，可以通过优选</p><p>IP选择最优的CDN服务器，<a href="https://github.com/badafans/better-cloudflare-ip">优选IP可以参考这个github工程</a></p></li><li><p><a href="https://www.cloudflare.com/zh-cn/">cloudfare</a> 提供了worker反向代理功能，可以自定义添加worker，提供一个提升科学上网速度的脚本</p><pre><code class="language-js">addEventListener('fetch',event =&gt; {  let url=new URL(event.request.url);  url.hostname='xxxx.xx'; // v2ray服务器的伪装网址  let request=new Request(url,event.request);  event.respondWith(    fetch(request)  )})</code></pre></li></ul><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://www.cnblogs.com/taostaryu/p/10547132.html">https://www.cnblogs.com/taostaryu/p/10547132.html</a></p></li><li><p><a href="https://www.pianshen.com/article/9900131597/">https://www.pianshen.com/article/9900131597/</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代理&quot;&gt;代理&lt;/h2&gt;
&lt;p&gt;​	代理其实就是一个中介，A和B本来可以直连，中间插入一个C，C就是中介。刚开始的时候，代理多数是帮助内网client访问外网server用的后来出现了反向代理，&quot;反向&quot;这个词在这儿的意思其实是指方向相反，即代理将来自外网客户端的请求</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="代理" scheme="http://example.com/tags/%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>ARP攻击(网关欺骗)</title>
    <link href="http://example.com/2021/06/20/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
    <id>http://example.com/2021/06/20/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</id>
    <published>2021-06-20T14:28:04.000Z</published>
    <updated>2021-08-01T15:26:05.045Z</updated>
    
    <content type="html"><![CDATA[<p>​最近家中的网络一直不稳定，360报ARP攻击，重新插拔网线网络会通一段时间，但是过一会又不行了，遂了解了相关的背景知识。中间的曲折就不说了，最后具体原因是家中的组网是二级路由，两个路由都开启了DHCP分配地址，由于组网问题造成局域网中有两个网关。解决办法也很简单网上提供了2种方案。</p><p><img src="/2021/06/20/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/ac4bd11373f0820292b1b9c841fbfbedab641b21.png" alt="二级路由"></p><ul><li>第一种就是重新进行组网</li></ul><pre><code>[二级路由组网方案](https://www.dgzj.com/baike/92924.html)。</code></pre><ul><li>我这里通过第二种方法通过arp命令强行绑定网关和mac地址来解决网关冲突问题。</li></ul><pre><code>[Window10强行绑定ip和Mac地址的命令](https://www.jianshu.com/p/8b3dba40556f?from=singlemessage)# netsh i i show in# netsh -c i i add ne idx ip mac</code></pre><p>​如果局域网中有一台恶意的主机伪装成网关就可以抓取局域网中所有的信息，在局域网要注意个人信息的安全，最好绑定使用arp命令绑定网关。</p><pre><code>## 扩展阅读[Arp攻击 Arpspoof](https://www.jianshu.com/p/bbf50dace855)  [Arp攻击原理](https://www.zhihu.com/question/20338649?sort=created)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​	最近家中的网络一直不稳定，360报ARP攻击，重新插拔网线网络会通一段时间，但是过一会又不行了，遂了解了相关的背景知识。中间的曲折就不说了，最后具体原因是家中的组网是二级路由，两个路由都开启了DHCP分配地址，由于组网问题造成局域网中有两个网关。解决办法也很简单网上提供</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="ARP" scheme="http://example.com/tags/ARP/"/>
    
  </entry>
  
</feed>
