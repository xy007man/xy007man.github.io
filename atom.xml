<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>study hungry,study foolish</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-08-31T13:54:06.815Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何观测Page Cache</title>
    <link href="http://example.com/2024/08/31/%E8%A7%82%E6%B5%8BPage-Cache/"/>
    <id>http://example.com/2024/08/31/%E8%A7%82%E6%B5%8BPage-Cache/</id>
    <published>2024-08-31T13:16:17.000Z</published>
    <updated>2024-08-31T13:54:06.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、什么是Page-Cache？">一、什么是Page Cache？</h2><p>为了提升对文件的读写效率，Linux 内核会以页大小（4KB）为单位，将文件划分为多数据块。当用户对文件中的某个数据块进行读写操作时，内核首先会申请一个内存页（称为 页缓存）与文件中的数据块进行绑定。如下图所示蓝色的地方就是Page Cache，很明显Page Cache是内核管理的内存，也就是说，它属于内核不属于用户。<br><img src="/2024/08/31/%E8%A7%82%E6%B5%8BPage-Cache/page_cache.png" alt="image-20210907004445908"></p><h2 id="二、如何观测Page-Cache">二、如何观测Page Cache</h2><pre><code class="language-shell">cat /proc/meminforoot@vultr:~# cat /proc/meminfo MemTotal:         979896 kBMemFree:           78116 kBMemAvailable:     451656 kBBuffers:           95416 kBCached:           374544 kBSwapCached:        18972 kBActive:           303408 kBInactive:         324400 kBActive(anon):      51252 kBInactive(anon):   118308 kBActive(file):     252156 kBInactive(file):   206092 kBUnevictable:       27476 kBMlocked:           27476 kBSwapTotal:       2457596 kBSwapFree:        2390652 kBZswap:                 0 kBZswapped:              0 kBDirty:              1764 kBWriteback:             0 kBAnonPages:        181836 kBMapped:            84972 kBShmem:              2808 kBKReclaimable:      71172 kB</code></pre><p>Active(file) + Inactive(file)即文件页，Active(anon)+Inactive(anon)即匿名页均属于Page Cacke</p><h2 id="三、文件页">三、文件页</h2><p>文件页，即与磁盘文件存在映射关系的内存页(有文件背景的页面)，例如进程代码段、文件的映射页等 ,他们有对应的硬盘文件，因此如果要交换，可以直接和硬盘对应的文件进行交换。内存紧张时，非dirty的文件页可以直接drop掉。Active(file) + Inactive(file)是与文件对应的内存页。</p><h2 id="四、匿名页">四、匿名页</h2><p>匿名页，没有文件背景的页面（即没有与磁盘文件存在任何映射关系的内存页面），如stack，heap，数据段，共享内存。SwapCached是打开Swap分区后，把Active(anon)+Inactive(anon)这2项的匿名页交换到磁盘，然后读取到内存后分配的内存。Shmem共享内存是指匿名共享映射的这种方式映射的内存，比如tmpfs（临时文件系统）</p><h2 id="五、为什么需要Page-Cache">五、为什么需要Page Cache</h2><p>减少I/O，提升应用的I/O速度</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、什么是Page-Cache？&quot;&gt;一、什么是Page Cache？&lt;/h2&gt;
&lt;p&gt;为了提升对文件的读写效率，Linux 内核会以页大小（4KB）为单位，将文件划分为多数据块。当用户对文件中的某个数据块进行读写操作时，内核首先会申请一个内存页（称为 页缓存）与文</summary>
      
    
    
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>微信小游戏桌球辅助器</title>
    <link href="http://example.com/2021/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%A1%8C%E7%90%83%E8%BE%85%E5%8A%A9%E5%99%A8/"/>
    <id>http://example.com/2021/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%A1%8C%E7%90%83%E8%BE%85%E5%8A%A9%E5%99%A8/</id>
    <published>2021-10-17T06:58:12.000Z</published>
    <updated>2021-10-17T08:56:39.129Z</updated>
    
    <content type="html"><![CDATA[<p>​最近在玩了一下微信小游戏中的桌球，游戏中自带的瞄准线太短了，就想找一个辅助器。在GitHub上搜索了半天没有发现特别好用的，GitHub上一般都是基于PC版的或者是需要用adb连接PC（晕，我玩个手机游戏还需要连着电脑？）。于是打算自己动手做一个。</p><h2 id="基本思路">基本思路</h2><ul><li><p>确定瞄准圆环的位置：将圆环的图片用抠图工具截取出来，使用opencv中的<code>matchTemplate</code>进行图像匹配（图中矩形）</p></li><li><p>确定瞄准线的坐标：使用深度优先算法，搜索瞄准圆环周边的白色像素坐标，然后取平均值，得到瞄准线的坐标（在图中两个圆环中间区域中搜索白色像素）</p></li><li><p>画出瞄准线：连接第一步确定的瞄准圆环圆心和第二步确定的瞄准线坐标画出瞄准线，另外需要注意的是我们画的是射线，需要通过这两点的相对位置，来确定射线的方向</p></li><li><p>在手机屏幕中显示出辅助线：利用android的的护眼模式的原理，创建一个透明的图层，覆盖在游戏上，绘制这个透明图层就能看到辅助线</p><p><img src="/2021/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%A1%8C%E7%90%83%E8%BE%85%E5%8A%A9%E5%99%A8/res.jpg" alt="res"></p></li></ul><h2 id="工程目录结构">工程目录结构</h2><ul><li>app主要负责屏幕截图、透明图层创建、绘制辅助线（本人不太了解android app开发，所以这部分代码只是勉强能用哈）</li><li>Billiards_SDK是JNI层，主要是进行瞄准圆环的匹配，确定辅助线坐标</li></ul><p><img src="/2021/10/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E6%B8%B8%E6%88%8F%E6%A1%8C%E7%90%83%E8%BE%85%E5%8A%A9%E5%99%A8/image-20211017153332240.png" alt="image-20211017153332240"></p><hr><h2 id="辅助工具的使用">辅助工具的使用</h2><ul><li>使用android studio编译工程，将生成的apk文件push到手机中安装（第一次安装时需要悬浮权限、读取sdcard权限及录屏权限，依次允许就行）</li><li>将<code>Tball\other\circle.jpg</code>图像文件push到手机<code>/sdcard/Pictures</code>文件夹下，用于匹配瞄准环（我的手机屏幕分辨率是1080x2400，所以不同分辨率的手机需要自行截取圆环图像进行替换）</li><li>打开Tball apk后，分别点击<code>启动Service</code>、<code>初始化服务</code>，然后将apk切换到后台，之后正常启动游戏即可（有的手机可能会误杀后台进程造成辅助失效，需要手动设置一下电源管理）</li></ul><hr><h2 id="本地运行环境">本地运行环境</h2><ul><li>手机：荣耀V30 pro</li><li>android 版本：Android 10</li></ul><hr><h2 id="项目GitHub链接">项目GitHub链接</h2><ul><li><a href="https://github.com/xy007man/Tball">https://github.com/xy007man/Tball</a></li></ul><hr><h2 id="鸣谢（排名不分先后-）">鸣谢（排名不分先后~）</h2><ul><li><p>Android权限框架：<a href="https://github.com/getActivity/XXPermissions">https://github.com/getActivity/XXPermissions</a></p></li><li><p>MediaProjection 截屏、录屏Demo：<a href="https://github.com/jiashuaishuai/MediaProjectionDemo">https://github.com/jiashuaishuai/MediaProjectionDemo</a></p></li><li><p>自定义View之自动刷新View：<a href="https://blog.csdn.net/qq_16519957/article/details/88768025">https://blog.csdn.net/qq_16519957/article/details/88768025</a></p></li><li><p>Android如何实现全局的护眼模式：<a href="https://blog.csdn.net/weixin_42433094/article/details/119137569">https://blog.csdn.net/weixin_42433094/article/details/119137569</a></p></li><li><p>腾讯桌球助手：<a href="https://github.com/CSUFT-Running-Bug/billiard-assistant">https://github.com/CSUFT-Running-Bug/billiard-assistant</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​	最近在玩了一下微信小游戏中的桌球，游戏中自带的瞄准线太短了，就想找一个辅助器。在GitHub上搜索了半天没有发现特别好用的，GitHub上一般都是基于PC版的或者是需要用adb连接PC（晕，我玩个手机游戏还需要连着电脑？）。于是打算自己动手做一个。&lt;/p&gt;
&lt;h2 id</summary>
      
    
    
    
    <category term="JNI" scheme="http://example.com/categories/JNI/"/>
    
    
    <category term="辅助器" scheme="http://example.com/tags/%E8%BE%85%E5%8A%A9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>记录一道面试题</title>
    <link href="http://example.com/2021/09/24/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2021/09/24/%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2021-09-24T12:54:12.000Z</published>
    <updated>2021-09-24T12:54:15.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述">题目描述</h2><p>​用C++实现一个String类，做成共享库，并通过googletest做单元测试，编写测试用例，要求使用CMakeLists组织整个工程。String类应包含一个成员变量char* m_data和以下函数：</p><ul><li><p>默认构造函数</p></li><li><p>构造函数，参数为const char*</p></li><li><p>复制构造</p></li><li><p>移动构造</p></li><li><p>析构</p></li><li><p>等号重载</p></li><li><p>+=重载，实现追加String类，即追加字符串，例 String a = “abc”, b= “def”; a += b; //a = “abcdef”</p></li><li><p>反转字符串</p></li><li><p>以某个字符分割字符串，返回List<string>，例String a = “abc def g”; 输出为{“abc”, “def”, “g”}</string></p></li></ul><p>​这个题目考察的是C++的基础能力和工程能力，做一下还蛮有意思的~~</p><hr><h2 id="目录结构">目录结构</h2><pre><code class="language-shell">└─string    │  CMakeLists.txt    │  readme.md    │    ├─3rd_party # gtest 依赖库和头文件    │  ├─gmock    │  │  │  gmock-actions.h    │  │  │  gmock-cardinalities.h    │  │  │  gmock-function-mocker.h    │  │  │  gmock-matchers.h    │  │  │  gmock-more-actions.h    │  │  │  gmock-more-matchers.h    │  │  │  gmock-nice-strict.h    │  │  │  gmock-spec-builders.h    │  │  │  gmock.h    │  │  │    │  │  └─internal    │  │      │  gmock-internal-utils.h    │  │      │  gmock-port.h    │  │      │  gmock-pp.h    │  │      │    │  │      └─custom    │  │              gmock-generated-actions.h    │  │              gmock-matchers.h    │  │              gmock-port.h    │  │              README.md    │  │    │  ├─gtest    │  │  │  gtest-death-test.h    │  │  │  gtest-matchers.h    │  │  │  gtest-message.h    │  │  │  gtest-param-test.h    │  │  │  gtest-printers.h    │  │  │  gtest-spi.h    │  │  │  gtest-test-part.h    │  │  │  gtest-typed-test.h    │  │  │  gtest.h    │  │  │  gtest_pred_impl.h    │  │  │  gtest_prod.h    │  │  │    │  │  └─internal    │  │      │  gtest-death-test-internal.h    │  │      │  gtest-filepath.h    │  │      │  gtest-internal.h    │  │      │  gtest-param-util.h    │  │      │  gtest-port-arch.h    │  │      │  gtest-port.h    │  │      │  gtest-string.h    │  │      │  gtest-type-util.h    │  │      │    │  │      └─custom    │  │              gtest-port.h    │  │              gtest-printers.h    │  │              gtest.h    │  │              README.md    │  │    │  └─lib    │          libgmock.a    │          libgmock_main.a    │          libgtest.a    │          libgtest_main.a    │    ├─app # 测试二进制存放路径    │      test    │    ├─build    ├─inc # String 共享库对外提供的头文件    │      String.h    │    ├─lib # String 共享库存放路径    │      libstring.so    │    ├─src # String 类的实现    │      CMakeLists.txt    │      String.cpp    │    └─test # gtest 测试目录            CMakeLists.txt            gtest.cpp            main.cpp</code></pre><hr><h2 id="工程编译方法">工程编译方法</h2><pre><code class="language-shell">cd build # 进入工程根目录下build目录cmake ..make../app/test # 执行app目录下可执行文件</code></pre><hr><h2 id="调试环境">调试环境</h2><ul><li>cmake version 3.16.3</li><li>Linux version 5.11.0-34-generic</li><li>gcc 9.3.0</li><li>ubuntu 20.04.1</li></ul><hr><h2 id="GitHub链接">GitHub链接</h2><ul><li><a href="https://github.com/xy007man/string">https://github.com/xy007man/string</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;题目描述&lt;/h2&gt;
&lt;p&gt;​	用C++实现一个String类，做成共享库，并通过googletest做单元测试，编写测试用例，要求使用CMakeLists组织整个工程。String类应包含一个成员变量char* m_data和以下函数：&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="C/C++" scheme="http://example.com/categories/C-C/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg学习：window环境搭建</title>
    <link href="http://example.com/2021/09/07/ffmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2021/09/07/ffmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2021-09-06T16:33:52.000Z</published>
    <updated>2021-09-06T16:47:41.561Z</updated>
    
    <content type="html"><![CDATA[<p>​ffmpeg vs2019 环境搭建方法。</p><span id="more"></span><h2 id="将依赖的dll拷贝到工程根目录">将依赖的dll拷贝到工程根目录</h2><pre><code class="language-c">├─ffmpeg_lib_dll  // 此目录存放已经编译好的ffmpeg二进制文件和头文件│  ├─bin│  │  ├─win32 // ffmpeg dll│  │  └─win64│  ├─include // 头文件│  │  ├─libavcodec│  │  ├─libavdevice│  │  ├─libavfilter│  │  ├─libavformat│  │  ├─libavutil│  │  ├─libpostproc│  │  ├─libswresample│  │  └─libswscale│  ├─lib│  │  ├─win32 // ffmpeg lib│  │  └─win64│  └─src│      └─TestFFMpeg│          └─x64│              └─Debug│                  └─TestFFMpeg.tlog└─source    └─helloword // 把ffmpeg dll文件拷贝到此文件夹下        └─Debug            └─helloword.tlog</code></pre><p><img src="/2021/09/07/ffmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210907004445908.png" alt="image-20210907004445908"></p><hr><h2 id="配置附加目录（C-C-、链接器）">配置附加目录（C/C++、链接器）</h2><p><img src="/2021/09/07/ffmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210907003555086.png" alt="image-20210907003555086"></p><p><img src="/2021/09/07/ffmpeg%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/image-20210907003809294.png" alt="image-20210907003809294"></p><hr><h2 id="FFmpeg-第一个-Hello-Word">FFmpeg 第一个 Hello Word</h2><pre><code class="language-c++">#include &lt;stdio.h&gt;extern "C" {#include &lt;libavcodec/avcodec.h&gt;}#pragma comment(lib, "avcodec.lib")int main(){printf("%s\n", avcodec_configuration());return 0;}</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	ffmpeg vs2019 环境搭建方法。&lt;/p&gt;</summary>
    
    
    
    <category term="ffmpeg" scheme="http://example.com/categories/ffmpeg/"/>
    
    
    <category term="ffmpeg" scheme="http://example.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>ffmpeg学习：实现一个简单解码器</title>
    <link href="http://example.com/2021/09/07/ffmpeg%E5%AD%A6%E4%B9%A0_MP4/"/>
    <id>http://example.com/2021/09/07/ffmpeg%E5%AD%A6%E4%B9%A0_MP4/</id>
    <published>2021-09-06T16:33:52.000Z</published>
    <updated>2021-09-07T15:25:16.705Z</updated>
    
    <content type="html"><![CDATA[<p>​一个简单的解码MP4文件的ffmpeg解码器。</p><span id="more"></span><h2 id="FFmpeg-基本流程图">FFmpeg 基本流程图</h2><p><img src="/2021/09/07/ffmpeg%E5%AD%A6%E4%B9%A0_MP4/image-20210907232217743.png" alt="image-20210907232217743"></p><hr><h2 id="FFmpeg-层次结构">FFmpeg 层次结构</h2><p><img src="/2021/09/07/ffmpeg%E5%AD%A6%E4%B9%A0_MP4/image-20210907232400006.png" alt="image-20210907232400006"></p><hr><h2 id="简单的解码器实现代码">简单的解码器实现代码</h2><pre><code class="language-c++"></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	一个简单的解码MP4文件的ffmpeg解码器。&lt;/p&gt;</summary>
    
    
    
    <category term="ffmpeg" scheme="http://example.com/categories/ffmpeg/"/>
    
    
    <category term="ffmpeg" scheme="http://example.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>vector</title>
    <link href="http://example.com/2021/09/05/vector/"/>
    <id>http://example.com/2021/09/05/vector/</id>
    <published>2021-09-05T13:49:06.000Z</published>
    <updated>2021-09-24T12:44:59.521Z</updated>
    
    <content type="html"><![CDATA[<p>​记录几个 <code>vecotor</code> 易混淆的几个API用法。</p><span id="more"></span><h2 id="reserve-和-resize"><code>reserve</code> 和 <code>resize</code></h2><ul><li><code>reserve</code>增加了<code>vector</code>的<code>capacity</code>，但是它的<code>size</code>没有改变。<code>reserve</code>是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素。加入新的元素时，要调用<code>push_back()</code>/<code>insert()</code>函数。</li><li><code>resize</code>改变了<code>vector</code>的<code>capacity</code>同时也增加了它的<code>size</code>。<code>resize</code>是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了，因此当加入新的元素时，用<code>operator[]</code>操作符，或者用迭代器来引用元素对象。此时再调用<code>push_back()</code>函数，是加在这个新的空间后面的。</li><li>如果<code>reserve(n)</code>函数的<code>n</code>的大小比<code>vector</code>原来的容量小。<code>capacity</code>没有变化。<code>size</code>也没有变：</li><li>如果<code>resize(n)</code>函数的<code>n</code>比<code>vector</code>原来的<code>size</code>小，结果是<code>size</code>减小到<code>n</code>，然后删除<code>n</code>之后的数据。</li></ul><pre><code class="language-c++">vector&lt;int&gt; myVec;myVec.reserve(100);     // 新元素还没有构造,                        // 此时不能用[]访问元素for (int i = 0; i &lt; 100; i++){     myVec.push_back(i); //新元素这时才构造}myVec.resize(102);      // 用元素的默认构造函数构造了两个新的元素myVec[100] = 1;         // 直接操作新元素myVec[101] = 2; </code></pre><hr><h2 id="clear"><code>clear</code></h2><ul><li><p><code>clear</code> 函数不会释放内存，即改变 <code>capacity</code>，只会将<code>size</code>改为0</p></li><li><p>用<code>swap</code>来帮助释放内存</p><pre><code class="language-c++">vector&lt;int&gt; nums; nums.push_back(1);nums.push_back(1);nums.push_back(2);nums.push_back(2); vector&lt;int&gt;().swap(nums); //或者 nums.swap(vector&lt;int&gt;())</code></pre></li></ul><hr><h2 id="emplace-back-和-push-back"><code>emplace_back</code> 和 <code>push_back</code></h2><ul><li><code>emplace_back</code>可以原地构造对象，然后加入到容器中，可以减少一次拷贝或构造</li><li><code>push_back</code>向容器中加入一个右值元素（临时对象）的时候，首先会调用<strong>构造函数</strong>构造这个临时对象，然后优先选择调用<strong>移动构造函数</strong>，如果没有才会调用<strong>拷贝构造函数</strong>临时对象放入容器中。原来的临时变量释放。这样造成的问题是临时变量申请的资源就浪费。</li><li><code>emplace_back</code>函数要比<code>push_back</code>函数要快一倍</li></ul><hr><h2 id="参考链接">参考链接</h2><ul><li><a href="https://blog.csdn.net/weixin_38314865/article/details/118068565">https://blog.csdn.net/weixin_38314865/article/details/118068565</a></li><li><a href="https://www.cnblogs.com/qlee/archive/2011/05/16/2048026.html">https://www.cnblogs.com/qlee/archive/2011/05/16/2048026.html</a></li><li><a href="https://blog.csdn.net/acoolgiser/article/details/81018296">https://blog.csdn.net/acoolgiser/article/details/81018296</a></li><li><a href="https://blog.csdn.net/hyl999/article/details/106235821">https://blog.csdn.net/hyl999/article/details/106235821</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	记录几个 &lt;code&gt;vecotor&lt;/code&gt; 易混淆的几个API用法。&lt;/p&gt;</summary>
    
    
    
    <category term="C/C++" scheme="http://example.com/categories/C-C/"/>
    
    
    <category term="vector" scheme="http://example.com/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>preempt_count</title>
    <link href="http://example.com/2021/08/25/preempt_count/"/>
    <id>http://example.com/2021/08/25/preempt_count/</id>
    <published>2021-08-25T13:08:43.000Z</published>
    <updated>2021-08-25T14:02:31.900Z</updated>
    
    <content type="html"><![CDATA[<p>​<code>preempt_count</code>本质上是一个per-CPU的32位变量，<code>preempt_count</code>代表的是该进程是否可以被抢占，<code>peermpt_count</code>等于0的时候当前进程就可以被抢占，当小于0存在bug，大于0说明当前进程不可以被抢占。具体每一位含义如下图所示。</p><span id="more"></span><p><img src="/2021/08/25/preempt_count/v2-ef0af5be9cedb02bead54a28b4d31a5c_720w.jpg" alt="preempt_count"></p><hr><h2 id="hardirq相关">hardirq相关</h2><p>​<code>preempt_count</code>中的第16到19个bit表示hardirq count，它记录了进入hardirq/top half的嵌套次数。irq_enter()用于标记hardirq的进入，此时hardirq count的值会加1。irq_exit()用于标记hardirq的退出，hardirq count的值会相应的减1。如果hardirq count的值为正数，说明现在正处于hardirq上下文中，代码中可借助**in_irq()**宏实现快速判断。注意这里的命名是"in_irq"而不是"in_hardirq"。</p><p>​hardirq count占据4个bits，理论上可以表示16层嵌套，但现在Linux系统并不支持hardirq的嵌套执行，所以实际使用的只有1个bit。</p><pre><code class="language-c">#define hardirq_count() (preempt_count() &amp; HARDIRQ_MASK)#define in_irq()  (hardirq_count())#define __irq_enter()\do {\account_irq_enter_time(current);\preempt_count_add(HARDIRQ_OFFSET);\trace_hardirq_enter();\} while (0)#define __irq_exit()\do {\trace_hardirq_exit();\account_irq_exit_time(current);\preempt_count_sub(HARDIRQ_OFFSET);\} while (0)int __handle_domain_irq(struct irq_domain *domain, unsigned int hwirq,bool lookup, struct pt_regs *regs){struct pt_regs *old_regs = set_irq_regs(regs);unsigned int irq = hwirq;int ret = 0;irq_enter(); // 进入中断hardirq++#ifdef CONFIG_HISI_BBirq_trace_hook(0, 0, hwirq);irq_register_hook(old_regs);#endif#ifdef CONFIG_IRQ_DOMAINif (lookup)irq = irq_find_mapping(domain, hwirq);#endif/* * Some hardware gives randomly wrong interrupts.  Rather * than crashing, do something sensible. */if (unlikely(!irq || irq &gt;= nr_irqs)) {ack_bad_irq(irq);ret = -EINVAL;} else {generic_handle_irq(irq);}#ifdef CONFIG_HISI_BBirq_trace_hook(1, 0, hwirq);#endifirq_exit(); // 退出中断hardirq--set_irq_regs(old_regs);return ret;}</code></pre><hr><h2 id="softirq相关">softirq相关</h2><p>​<code>preempt_count</code>中的第8到15个bit表示softirq count，它记录了进入softirq的嵌套次数，如果softirq count的值为正数，说明现在正处于softirq上下文中。由于softirq在单个CPU上是不会嵌套执行的，因此和hardirq count一样，实际只需要一个bit(bit 8)就可以了。但这里多出的7个bits并不是因为历史原因多出来的，而是另有他用。</p><pre><code class="language-c++">void irq_exit(void){#ifndef __ARCH_IRQ_EXIT_IRQS_DISABLEDlocal_irq_disable();#elseWARN_ON_ONCE(!irqs_disabled());#endifaccount_irq_exit_time(current);preempt_count_sub(HARDIRQ_OFFSET);if (!in_interrupt() &amp;&amp; local_softirq_pending())invoke_softirq(); // 退出中断前，判断当前上下文不是软中断和硬中断，才会触发软中断(同一个cpu软中断不可嵌套)tick_irq_exit();rcu_irq_exit();trace_hardirq_exit(); /* must be last! */}asmlinkage __visible void __softirq_entry __do_softirq(void){unsigned long end = jiffies + MAX_SOFTIRQ_TIME;unsigned long old_flags = current-&gt;flags;int max_restart = MAX_SOFTIRQ_RESTART;struct softirq_action *h;bool in_hardirq;__u32 pending;int softirq_bit;/* * Mask out PF_MEMALLOC s current task context is borrowed for the * softirq. A softirq handled such as network RX might set PF_MEMALLOC * again if the socket is related to swap */current-&gt;flags &amp;= ~PF_MEMALLOC;pending = local_softirq_pending();account_irq_enter_time(current);__local_bh_disable_ip(_RET_IP_, SOFTIRQ_OFFSET); // 进入软中断前softirq++in_hardirq = lockdep_softirq_start();restart:/* Reset the pending bitmask before enabling irqs */set_softirq_pending(0);local_irq_enable();h = softirq_vec;while ((softirq_bit = ffs(pending))) {unsigned int vec_nr;int prev_count;h += softirq_bit - 1;vec_nr = h - softirq_vec;prev_count = preempt_count();kstat_incr_softirqs_this_cpu(vec_nr);trace_softirq_entry(vec_nr);h-&gt;action(h);trace_softirq_exit(vec_nr);if (unlikely(prev_count != preempt_count())) {pr_err("huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\n",       vec_nr, softirq_to_name[vec_nr], h-&gt;action,       prev_count, preempt_count());preempt_count_set(prev_count);}h++;pending &gt;&gt;= softirq_bit;}rcu_bh_qs();local_irq_disable();pending = local_softirq_pending();if (pending) {if (time_before(jiffies, end) &amp;&amp; !need_resched() &amp;&amp;    --max_restart)goto restart;wakeup_softirqd();}lockdep_softirq_end(in_hardirq);account_irq_exit_time(current);__local_bh_enable(SOFTIRQ_OFFSET); // 退软中断前softirq--WARN_ON_ONCE(in_interrupt());current_restore_flags(old_flags, PF_MEMALLOC);}</code></pre><p>​这个"他用"就是表示在进程上下文中，为了防止进程被softirq所抢占，关闭/禁止softirq的次数，比如每使用一次local_bh_disable()，softirq count高7个bits(bit 9到bit 15)的值就会加1，使用local_bh_enable()则会让softirq count高7个bits的的值减1。</p><p>​代码中可借助**in_softirq()**宏快速判断当前是否在softirq上下文：</p><pre><code class="language-c">#define softirq_count()  (preempt_count() &amp; SOFTIRQ_MASK)#define in_softirq() (softirq_count())</code></pre><hr><h2 id="上下文">上下文</h2><p>​**in_interrupt()**的宏专门用来判断当前是否在中断上下文中</p><pre><code class="language-c">#define irq_count() (preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_MASK | NMI_MASK)) #define in_interrupt()  (irq_count())</code></pre><p>与中断上下文相对应的就是俗称的进程上下文(process context)</p><pre><code class="language-c">#define in_task()  (!(preempt_count() &amp; (HARDIRQ_MASK | SOFTIRQ_OFFSET | NMI_MASK)))</code></pre><p>​在中断上下文中，调度是关闭的，不会发生进程的切换，这属于一种隐式的禁止调度，而在代码中，也可以使用preempt_disable()来显示地关闭调度，关闭次数由第0到7个bits组成的preemption count(注意不是preempt count)来记录。每使用一次preempt_disable()，preemption count的值就会加1，使用preempt_enable()则会让preemption count的值减1。preemption count占8个bits，因此一共可以表示最多256层调度关闭的嵌套。</p><p>​处于中断上下文，或者显示地禁止了调度，preempt_count()的值都不为0，都不允许睡眠/调度的发生，这两种场景被统称为atomic上下文，可由**in_atomic()**宏给出判断。</p><pre><code class="language-go">#define in_atomic()(preempt_count() != 0)</code></pre><p>​中断上下文、进程上下文和atomic上下文的关系大概可以表示成这样：</p><p><img src="/2021/08/25/preempt_count/v2-3d4d6ecfcdec4be8c270dadfea0bd29a_720w.jpg" alt="中断上下文、进程上下文和atomic上下文的关系"></p><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/88883239">https://zhuanlan.zhihu.com/p/88883239</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1J64y1r7mK">linux内核开发第31讲：中断上下文、进程上下文环境的进入时机</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	&lt;code&gt;preempt_count&lt;/code&gt;本质上是一个per-CPU的32位变量，&lt;code&gt;preempt_count&lt;/code&gt;代表的是该进程是否可以被抢占，&lt;code&gt;peermpt_count&lt;/code&gt;等于0的时候当前进程就可以被抢占，当小于0存在bug，大于0说明当前进程不可以被抢占。具体每一位含义如下图所示。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="preempt_count" scheme="http://example.com/tags/preempt-count/"/>
    
  </entry>
  
  <entry>
    <title>Linux nice 命令</title>
    <link href="http://example.com/2021/08/19/%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <id>http://example.com/2021/08/19/%E6%8C%87%E5%AE%9A%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</id>
    <published>2021-08-19T15:02:17.000Z</published>
    <updated>2021-08-19T15:18:57.190Z</updated>
    
    <content type="html"><![CDATA[<p>​Linux nice命令以更改过的优先序来执行程序，如果未指定程序，则会印出目前的排程优先序，内定的 adjustment 为 10，范围为 -20（最高优先序）到 19（最低优先序）。</p><p>使用权限：所有使用者。设定为负数需要管理者权限</p><span id="more"></span><h2 id="语法">语法</h2><pre><code class="language-shell">nice [-n adjustment] [-adjustment] [--adjustment=adjustment] [--help] [--version] [command [arg...]]</code></pre><h2 id="参数说明">参数说明</h2><ul><li><p>-n adjustment, -adjustment, --adjustment=adjustment 皆为将该原有优先序的增加 adjustment</p></li><li><p>–help 显示求助讯息</p></li><li><p>–version 显示版本资讯</p></li></ul><h2 id="实例">实例</h2><pre><code class="language-shell"># vi &amp; //后台运行[1] 15297# nice vi &amp; //设置默认优先级[2] 15298[1]+ Stopped         vi# nice -n 19 vi &amp; //设置优先级为19[3] 15299[2]+ Stopped         nice vi# nice -n -20 vi &amp; //设置优先级为 -20[4] 15300[3]+ Stopped         nice -n 19 vi# ps -l //显示进程F S  UID  PID PPID C PRI NI ADDR SZ WCHAN TTY     TIME CMD4 S   0 15278 15212 0 80  0 - 1208 wait  pts/2  00:00:00 bash0 T   0 15297 15278 0 80  0 - 2687 signal pts/2  00:00:00 vi0 T   0 15298 15278 0 90 10 - 2687 signal pts/2  00:00:00 vi0 T   0 15299 15278 1 99 19 - 2687 signal pts/2  00:00:00 vi4 T   0 15300 15278 3 60 -20 - 2687 signal pts/2  00:00:00 vi4 R   0 15301 15278 0 80  0 -  625 -   pts/2  00:00:00 ps[4]+ Stopped         nice -n -20 vi</code></pre><blockquote><p>注意：PRI表示进程当前的总优先级，值越小表示优先级越高，由进程默认的PRI加上NI得到，即PRI(new) = PRI(old) + NI。由上程序，进程默认的PRI是80，所以加上值为10的NI后，vi进程的PRI为90。 所以，需要注意的是，NI即niceness的值只是进程优先级的一部分，不能完全决定进程的优先级，但niceness值的绝对值越大，效果越显著。</p></blockquote><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://www.jianshu.com/p/fd3dec3cd393">Linux nice命令简要介绍</a></p></li><li><p><a href="https://www.runoob.com/linux/linux-comm-nice.html">Linux nice命令</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	Linux nice命令以更改过的优先序来执行程序，如果未指定程序，则会印出目前的排程优先序，内定的 adjustment 为 10，范围为 -20（最高优先序）到 19（最低优先序）。&lt;/p&gt;
&lt;p&gt;使用权限：所有使用者。设定为负数需要管理者权限&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Nice" scheme="http://example.com/tags/Nice/"/>
    
  </entry>
  
  <entry>
    <title>视频协议中常见算法</title>
    <link href="http://example.com/2021/08/17/%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/2021/08/17/%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/</id>
    <published>2021-08-17T14:18:06.000Z</published>
    <updated>2021-08-17T15:46:20.396Z</updated>
    
    <content type="html"><![CDATA[<p>​本文不推导具体公式，仅仅讲述一下在视频编码过程使用的算法。</p><p><img src="/2021/08/17/%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/20180416220957998.png" alt="编码流程图"></p><span id="more"></span><h2 id="运动估计（ME，Motion-Estimation）">运动估计（ME，Motion Estimation）</h2><ul><li>SAD、SATD、SSD、MSE、PSNR：视频编码失真测度，SAD和SATD常用在视频编码的模式选择</li><li>三步搜索、菱形搜索、六边形搜索：运动搜索算法，找到最佳匹配快</li><li>亚像素：根据相邻像素值计算得到，理论存在于实际像素之间的中间值，常用于提升运动搜索的精度</li></ul><h2 id="变换（T）">变换（T）</h2><ul><li>DST变换：H265帧内4x4模式亮度风量残差编码</li><li>DCT变换：H265除帧内4x4模式，其他残差编码均为DCT</li><li>Hadamard变换：用来计算SATD、编码H264直流分量，比DCT变换复杂度低</li></ul><h2 id="熵编码（Entropy-encode）">熵编码（Entropy encode）</h2><ul><li>CAVLC：实现简单，效率不如CABAC</li><li>CABAC：在不同的上下文环境中使用不同的概率模型来编码</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	本文不推导具体公式，仅仅讲述一下在视频编码过程使用的算法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/08/17/%E8%A7%86%E9%A2%91%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95/20180416220957998.png&quot; alt=&quot;编码流程图&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="视频" scheme="http://example.com/categories/%E8%A7%86%E9%A2%91/"/>
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>内核中的锁</title>
    <link href="http://example.com/2021/08/16/%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>http://example.com/2021/08/16/%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/</id>
    <published>2021-08-16T13:41:33.000Z</published>
    <updated>2021-08-16T13:59:13.323Z</updated>
    
    <content type="html"><![CDATA[<p>​内核中自旋锁、信号量/mutex、读写锁/顺序锁、RCU介绍。</p><span id="more"></span><h2 id="自旋锁">自旋锁</h2><h3 id="为什么需要自旋锁">为什么需要自旋锁</h3><p>​很多时候我们并不能采用其他的锁，比如读写锁、互斥锁、信号量等。一方面这些锁会发生上下文切换，他的时间是不可预期的，对于一些简单的、极短的临界区完全是一种性能损耗；另一方面在中断上下文是不允许睡眠的，除了自旋锁以外的其他任何形式的锁都有可能导致睡眠或者进程切换，这是违背了中断的设计初衷，会发生不可预知的错误。基于两点，我们需要自旋锁，他是不可替代的。</p><h3 id="为什么自旋锁会禁止抢占">为什么自旋锁会禁止抢占</h3><p>​这一点其实很好理解，当一个 CPU 获取到一把自旋锁之后，开始执行临界区代码，此时假设他的时间片运转完毕，进程调度会主动触发调度将其调走，执行另一个线程/进程，结果恰巧了这个线程/进程也需要用到该自旋锁，而上一个线程/进程还在停留在临界区内未释放锁，导致本进程无法获取到锁而形成死锁，所以自旋锁为了规避此类情形的出现从而直接禁止对已经开始运行的临界区设置禁止抢占标志。</p><h3 id="为什么临界区禁止睡眠">为什么临界区禁止睡眠</h3><p>​如果自旋锁锁住以后进入睡眠，而此时又不能进行处理器抢占，内核的调取器无法调取其他进程获得该 CPU，从而导致该 CPU 被挂起；同时该进程也无法自唤醒且一直持有该自旋锁，进一步会导致其他使用该自旋锁的位置出现死锁。</p><h3 id="spin-lock-系列的分别">spin_lock 系列的分别</h3><p>​每一种锁出现都有自己的原因，spin_lock 系列的锁就是为了解决这一个又一个的问题才会新增的各种自旋锁变种，这也符合现代计算机代码设计逻辑，首先是解决有无问题之后再解决崩溃问题，最后才是性能问题，没有什么设计能够逃得出这样一个框架。</p><p>​spin_lock 出现的原因上文已经介绍过了，目标就是为了解决当前内核中，某些场景下快速访问临界区的问题而存在的，所以他禁止了调度器抢占，所以不存在任何其他的进程会抢占该 CPU 的情况。但是，现代计算机为了能够更快的响应各种外部消息，所以存在各种类型的中断，比如网卡中断的到来，就一定会打断正在执行的 CPU 的进程，哪怕是当前的程序被 spin_lock 给锁住了，假设当前的中断也需要访问该 spin_lock 锁，那么就会导致死锁发生，如图：</p><p><a href="https://i.loli.net/2018/09/20/5ba3446040187.png"><img src="/2021/08/16/%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/5ba3446040187.png" alt="img"></a></p><p>所以为了应对自旋锁同时出现在硬件中断和进程上下文的情况，所以应该在进程执行临界区代码段的自旋锁上锁之前，首先就应该关闭当前 CPU 的中断，这样无论你发生什么情况，一旦被锁上就不再会被任何的情况抢走 CPU，这就是 spin_lock_irq 出现的原因，当然，由于需要关闭中断，会导致系统的响应降低，而且还会执行更多的代码，可能会导致性能下降。</p><p>​那么 spin_lock_irqsave 又为何需要存在，之前说过每一种类型变种的出现都是为了解决实际问题，那么这个类型锁的出现也是为了解决一些实际问题。如图所示：</p><p><a href="https://i.loli.net/2018/09/20/5ba346d89fbd6.png"><img src="/2021/08/16/%E5%86%85%E6%A0%B8%E4%B8%AD%E7%9A%84%E9%94%81/5ba346d89fbd6.png" alt="img"></a></p><p>​从图中可以看出，当进程在执行第一个 spin_lock_irq(&amp;lock1) 时已经关闭了中断，然后继续获取第二个自旋锁spin_lock_irq(&amp;lock2)，当 lock2 解锁后且 lock1 未解锁前这一段区域处于一种硬件中断开启的状态，这段代码仍然处于 lock1 的临界区，如果此时硬件中断也需要申请 lock1 锁会导致死锁，这是因为 spin_unlock_irq 在解锁时一定会将本地 CPU 的中断打开，从而导致硬件中断可以重新强制抢占 CPU，所以最好的方式就是 lock2 在锁之前保存当前的中断状态，在解锁时恢复当前的中断状态，这也就是 spin_lock_irqsave 需要存在的原因。自然地，这是一种更为线程安全的方案，但是他会带来比前面几种更加多的性能损耗。</p><h3 id="什么场合使用什么类型的自旋锁">什么场合使用什么类型的自旋锁</h3><p>既然都已经了解了三种自旋锁的变种，那么什么情况下适合什么样的锁呢？</p><h4 id="spin-lock-使用场景">spin_lock 使用场景</h4><p>​首先如果整个临界区都只位于进程上下文或者工作队列中，那么只需要采用最为方便的 spin_lock 即可，因为他不会发生中断抢占锁的情况，哪怕中断抢占进程上下文也不会导致中断由于申请自旋锁而导致死锁。</p><p>​还有一种情况就是在硬件中断中可以考虑使用 spin_lock 即可，因为硬件中断不存在嵌套（未必一定是这样，与平台有关），所以只需要简单的上锁即可， 可以不需要关闭中断，保存堆栈等。</p><h4 id="spin-lock-irq-使用场景">spin_lock_irq 使用场景</h4><p>​这个锁的变种适合在进程上下文/软中断 + 硬件中断这样的组合中使用，taskset 也是属于软中断的一种，所以也归在此类。当然，这种类型的变种同样适合软中断/taskset + 进程上下文的组合，因为关闭了硬件中断，从源头就禁止执行软中断代码，不过，对于这种类型的中断最好的方式是使用 spin_lock_bh 的方式，因为他只锁定软中断代码执行，而不关闭硬件中断，这样性能损耗更小。</p><h4 id="spin-lock-irqsave-使用场景">spin_lock_irqsave 使用场景</h4><p>​这种类型的使用方式是最为安全以及便捷的，毕竟不需要考虑会不会发生死锁的问题（代码本身引入的死锁不在此类），但是他也是性能损耗最大的代码，能不使用尽量不适用，在高速设备上，自旋锁已然成为了一种降低性能的瓶颈。他最好只出现在在需要尝试 spin_lock 之前无法确定是否已经关闭中断的代码才使用，如果代码能够确定在执行锁之前中断一定是打开的，那么使用 spin_lock_irq 是更佳的选择。</p><h4 id="spin-lock-bh-使用场景">spin_lock_bh 使用场景</h4><p>​这种类型的变种是一种比 spin_lock_irq 更轻量的变种，只关闭中断底半部，其实就是关闭了软中断、Tasklet以及 Timer 等的一个抢占能力，如果开发者确定编写的代码临界区只存在软中断/Tasklet/Timer + 进程上下文这样的组合，则最好考虑使用 spin_lock_bh 这样的锁来禁止软中断进行抢占。还有就是软中断与软中断自我抢占临界区访问时，也需要使用 spin_lock_bh 以上的中断锁，因为有可能软中断在执行的过程中，自己被硬件中断打断，然后又执行到同样的代码，在别的 CPU 执行还好说，毕竟软中断可以在不同的 CPU 上执行同一个中断函数，但是假设不幸运行在同一个 CPU 上，则会导致死锁。Tasklet 由于在运行过程中钟只会运行一个实例，所以不存在死锁问题，Tasklet与 Tasklet 的锁竞争只需要使用 spin_lock 即可。</p><hr><h2 id="信号量和mutex">信号量和mutex</h2><p>​网上有一篇关于信号量和mutex的深入分析的介绍 ，最后作者有一段总结：</p><p>​具体可以参照：<a href="https://blog.csdn.net/weixin_32521765/article/details/116923700">https://blog.csdn.net/weixin_32521765/article/details/116923700</a></p><blockquote><p>​我们看到对mutex的优化其实遵循了代码优化的一般原则，即集中优化整个代码执行中出现的hot-spot(引申到高概率spot)。因为在实际使用当中，大多数情况 下，mutex_lock与mutex_unlock之间的代码都比较简短，使得获得锁的进程可以很快释放锁(因此，从性能优化的角度，这个也可以作为使 用mutex的一条一般原则)。如果系统中大部分拥有互斥锁的进程在mutex_lock与unlock之间执行时间比较长，那么相对于使用 semaphore，我相信使用mutex会使得系统性能降低：因为很大的概率，mutex都经过一段spin(虽然这段时间极短)之后最终还是进入 sleep，而semaphore则直接进入sleep，没有了spin的过程。</p></blockquote><hr><h2 id="读写锁和顺序锁">读写锁和顺序锁</h2><pre><code class="language-c">//定义读写锁rwlock_t rwlock;//初始化读写锁rwlock_init(&amp;rwlock);//读锁定read_lock(&amp;rwlock);//读锁定并关闭中断read_lock_irq(&amp;rwlock);//读解锁read_unlock(&amp;rwlock);//读解锁并恢复中断read_unlock_irqrestore(&amp;rwlock);//写锁定write_lock(&amp;rwlock);//写锁定并关闭中断write_lock_irq(&amp;rwlock);//写解锁write_unlock(&amp;rwlock);//写解锁并恢复中断write_unlock_irqrestore(&amp;rwlock);</code></pre><pre><code class="language-c">//定义顺序锁seqlock_t seq_lock;//初始化顺序锁seqlock_init(&amp;seq_lock);//写锁定write_seqlock(seqlock_t * sl);write_seqlock_irq(seqlock_t * sl);//写解锁write_sequnlock(seqlock_t * sl);write_sequnlock_irqrestore(seqlock_t * sl);//读申请unsigned int read_seqbegin(const seqlock_t * sl);//读有效判定int read_seqretry(const seqlock_t * sl, unsigned start);//demodo{    unsigned int seqnum=read_seqbegin(&amp;seqlock);    //读操作&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; .}while(read_seqretry(&amp;seqlock,seqnum));</code></pre><ul><li>读写锁和顺序锁相同点：读操作和读操作不互斥、读写互斥、写写互斥</li><li>读写锁和顺序锁不同点：读写锁读优先，即写操作会等所有读操作完成，才会进入；顺序锁写优先，demo中的 <code>do while</code>就是读者发现写操作修改数据，尝试再次读取。即如果当前有其他读操作，写操作也会执行。</li></ul><hr><h2 id="RCU">RCU</h2><p>​RCU在驱动中用的相对比较少，可以参考这篇文章：<a href="https://blog.csdn.net/xabc3000/article/details/15335131">https://blog.csdn.net/xabc3000/article/details/15335131</a></p><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://www.byteisland.com/%E8%87%AA%E6%97%8B%E9%94%81-spin_lock%E3%80%81-spin_lock_irq-%E4%BB%A5%E5%8F%8A-spin_lock_irqsave-%E7%9A%84%E5%8C%BA%E5%88%AB/">自旋锁 spin_lock、 spin_lock_irq 以及 spin_lock_irqsave 的区别</a></p></li><li><p><a href="https://blog.csdn.net/weixin_32521765/article/details/116923700">linux semaphore性能,深层次探讨mutex与semaphore之间的区别</a></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	内核中自旋锁、信号量/mutex、读写锁/顺序锁、RCU介绍。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>如何Review代码</title>
    <link href="http://example.com/2021/08/15/%E5%A6%82%E4%BD%95review%E4%BB%A3%E7%A0%81/"/>
    <id>http://example.com/2021/08/15/%E5%A6%82%E4%BD%95review%E4%BB%A3%E7%A0%81/</id>
    <published>2021-08-15T06:15:34.000Z</published>
    <updated>2021-08-15T06:17:47.742Z</updated>
    
    <content type="html"><![CDATA[<h1>review 前准备</h1><ul><li>代码开发人员做好自review和自测试，杜绝代码中的低级错误</li><li>参加review的人员需要对代码业务有一定的了解，代码开发人员提前做好方案详细设计串讲</li><li>完成部分代码即可发起review，小步快跑，减少每次review代码量</li></ul><h1>review什么</h1><ul><li>专项review：参考《C/C++编程规范》、《C/C++安全编程规范》，这部分在开发人员自review时就应该做好</li><li>功能review：代码实现是否满足需求</li><li>可读性：圈复杂度、变量名命名合理、目录划分、函数代码行数、无冗余代码等等</li><li>可维护性/可扩展：数据结构/接口定义合理、兼容其他平台、提供测试接口、提供相关关键日志</li><li>性能review：算法实现是否最优，是否有执行效率低的代码等</li></ul><h1>写在最后</h1><p>​对于代码要做到<strong>谁开发，谁保护；谁污染，谁治理</strong>。对产品代码划分责任田，责任田主对代码的质量长期负责。之前和若干合作方合作过，合作方交付的代码质量堪忧，我认为其中一条就是合作方不对代码质量长期负责，合作方交付代码之后就没人管了。第一版代码的开发人员对代码的日后演进有至关重要的作用，如果第一版质量就很差，以后代码问题会像滚雪球一样问题越来越严重。一个Cisco来的专家讲过他们review代码方式：每个源码文件都有相关的review人员，这些人员都是当初开发这段代码的人员或者维护过这段代码的人员，无论他们目前在公司做什么工作，一旦有人改了这段代码，这些人都会收到相关的邮件review通知。他就曾经半夜收到某大领导的电话，这个人多年前曾维护过这段代码，给他提了好多有效的review意见。</p><p>​最后的最后，代码的质量决定的根本因素还是开发代码人员，一个程序员的基本素养是啥？自己埋下的坑自己填，自己的BUG自己能解。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;review 前准备&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;代码开发人员做好自review和自测试，杜绝代码中的低级错误&lt;/li&gt;
&lt;li&gt;参加review的人员需要对代码业务有一定的了解，代码开发人员提前做好方案详细设计串讲&lt;/li&gt;
&lt;li&gt;完成部分代码即可发起review，小</summary>
      
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>内核同步机制：自旋锁</title>
    <link href="http://example.com/2021/08/08/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E8%87%AA%E6%97%8B%E9%94%81/"/>
    <id>http://example.com/2021/08/08/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E8%87%AA%E6%97%8B%E9%94%81/</id>
    <published>2021-08-08T13:47:19.000Z</published>
    <updated>2021-08-08T13:49:00.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自旋锁系列函数">自旋锁系列函数</h2><table><thead><tr><th>函数</th><th>功能说明</th></tr></thead><tbody><tr><td>void spin_lock(spinlock_t *lock)</td><td>进程和进程之间同步</td></tr><tr><td>void spin_lock_bh(spinlock_t *lock)</td><td>和本地软中断之间同步</td></tr><tr><td>void spin_lock_irq(spinlock_t *lock)</td><td>和本地硬件中断之间同步</td></tr><tr><td>void spin_lock_irqsave(lock, flags)</td><td>和本地硬件中断之间同步并保存本地中断状态</td></tr><tr><td>int spin_trylock(spinlock_t *lock)</td><td>尝试获取锁，如果成功返回非0值，否则返回0值</td></tr></tbody></table><hr><h2 id="自旋锁特点">自旋锁特点</h2><ul><li><code>spinlock</code>是一种死等的锁机制</li><li>临界区执行时间短且不可睡眠，可以在中断上下文中使用。由于<code>spinlock</code>死等的这种特性，如果临界区执行时间长，那么不断在临界区死等的执行单元会浪费CPU资源</li></ul><hr><h2 id="自旋锁的公平性">自旋锁的公平性</h2><pre><code class="language-c">typedef struct spinlock {union {struct raw_spinlock rlock;#ifdef CONFIG_DEBUG_LOCK_ALLOC# define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))struct {u8 __padding[LOCK_PADSIZE];struct lockdep_map dep_map;};#endif};} spinlock_t;typedef struct raw_spinlock {arch_spinlock_t raw_lock;#ifdef CONFIG_GENERIC_LOCKBREAKunsigned int break_lock;#endif#ifdef CONFIG_DEBUG_SPINLOCKunsigned int magic, owner_cpu;void *owner;#endif#ifdef CONFIG_DEBUG_LOCK_ALLOCstruct lockdep_map dep_map;#endif} raw_spinlock_t;typedef struct {union {u32 slock;struct __raw_tickets {#ifdef __ARMEB__u16 next;u16 owner;#elseu16 owner; // owner表示持有这个数字的thread可以获取自旋锁u16 next; // next表示如果后续再有thread请求获取这个自旋锁，就给他分配这个数字#endif} tickets;};} arch_spinlock_t;</code></pre><ul><li><p>数据结构：spinlock_t --&gt; raw_spinlock_t --&gt; arch_spinlock_t</p></li><li><p>自旋锁公平调度实现方式</p><ul><li>刚开始owner = next = 0</li><li>第一个thread获取spinlock，可以获取成功，此时owner = 0， next = 0</li><li>第二个thread获取spinlock，如果第一个thread还没有释放spinlock，则next++，next变为1</li><li>第三个thread获取spinlock，如果第一个thread还没有释放spinlock，则next++，next变为2</li><li>此时第一个thread释放spinlock，则执行owner++，owner = 1</li><li>虽然此时第二个thread和第三个thread都在等待spinlock，但是因为第二个thread的next=owner，所以第二个thread可以获取到spinlock，第三个thread则继续等待，这样保证了spinlock的唤醒机制是先到先唤醒，后到后唤醒，保证了公平性。</li></ul><pre><code class="language-c">static inline void arch_spin_lock(arch_spinlock_t *lock){unsigned long tmp;u32 newval;arch_spinlock_t lockval;prefetchw(&amp;lock-&gt;slock);    // 下面这段汇编翻译成C语言就是    /*    lockval = lock-&gt;slock;    newval = lockval + (1 &lt;&lt; TICKET_SHIFT) &lt;=等价于=&gt; newval.ticket.next = lockval.tickets.next++    lockval = newval    */__asm__ __volatile__("1:ldrex%0, [%3]\n""add%1, %0, %4\n""strex%2, %1, [%3]\n""teq%2, #0\n""bne1b": "=&amp;r" (lockval), "=&amp;r" (newval), "=&amp;r" (tmp): "r" (&amp;lock-&gt;slock), "I" (1 &lt;&lt; TICKET_SHIFT): "cc");while (lockval.tickets.next != lockval.tickets.owner) { // 死等循环，直到 owner == nextwfe(); // cpu进入低功耗状态lockval.tickets.owner = ACCESS_ONCE(lock-&gt;tickets.owner);}smp_mb();}</code></pre></li></ul><hr><h2 id="参考链接">参考链接</h2><ul><li><p>自旋锁Spinlock <a href="https://blog.csdn.net/longwang155069/article/details/52055876">https://blog.csdn.net/longwang155069/article/details/52055876</a></p></li><li><p>linux内核开发第18讲：spinlock在SMP下的源码实现 <a href="https://www.bilibili.com/video/BV1Yh411R7YC">https://www.bilibili.com/video/BV1Yh411R7YC</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自旋锁系列函数&quot;&gt;自旋锁系列函数&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;功能说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;void spin_lock(spinlock_t *lock</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="自旋锁" scheme="http://example.com/tags/%E8%87%AA%E6%97%8B%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>H.265/HEVC环路滤波技术</title>
    <link href="http://example.com/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/"/>
    <id>http://example.com/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/</id>
    <published>2021-08-07T13:52:53.000Z</published>
    <updated>2021-08-07T13:56:25.191Z</updated>
    
    <content type="html"><![CDATA[<p>​<code>H.265/HEVC</code> 仍然采用基于块的混合编码框架，方块效应、振铃效应、颜色偏差以及图像模糊等失真效应仍存在。为降低这类失真对视频的影响，<code>H.265/HEVC</code>采用环路滤波技术，包括去方块滤波（Deblocking Filter）和像素自适应补偿（Sample Adaptive Offset）两个模块。去方块滤波用于降低方块效应，像素自适应补偿用于改善振铃效应。如图所示可以看出，经过滤波的重构像素才能作为后续编码像素参考使用。环路滤波处理后的重建图像更有利于参考，进一步减小后续编码像素的预测残差，可有效地提高视频的主观质量。</p><span id="more"></span><p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/%E7%8E%AF%E8%B7%AF%E6%BB%A4%E6%B3%A2.png" alt="环路滤波"></p><hr><h2 id="块效应">块效应</h2><p>块效应是指图像中编码块编解不连续，如图所示，压缩重建图像有明显的方块效应，严重影响主观质量。</p><p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/421096-20160518153202404-1659522803.gif" alt="img"></p><hr><h3 id="块效应产生原因">块效应产生原因</h3><ul><li>各个块变换量化编码过程独立，相当于对各个块使用了不同参数的滤波器分别滤波，因此各块引入的量化误差大小及其分布特征相互独立，导致相邻编解的不连续。</li><li>运动补偿预测过程中，相邻块的预测值可能来自不同图像的不同位置，这样就导致预测残差信号在块的边界产生数值不连续。</li><li>时域预测技术使得参考图像中窜在的边界不连续可能会传递到后续编码图像</li></ul><hr><h3 id="去方块滤波技术">去方块滤波技术</h3><p>​滤波的主要工作就是判断块边界是否需要进行滤波，并且决定采用的滤波强度（大白话就是对边界多少个像素进行平滑，即取均值）。过强的滤波会造成图像细节不必要的平滑，而缺乏滤波则会造成块效应。</p><ul><li>确定滤波边界</li><li>计算边界强度</li><li>对亮度分量进行滤波开关决策、滤波强弱选择</li><li>滤波</li></ul><hr><h2 id="振铃效应">振铃效应</h2><p>所谓“振铃”，就是指输出图像的灰度剧烈变化处产生的震荡，就好像钟被敲击后产生的空气震荡。</p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/振铃效应.png" alt="振铃效应" style="zoom:200%;"><hr><h3 id="振铃效应产生原因">振铃效应产生原因</h3><ul><li><p><code>H.265/HEVC</code> 采用基于块的<code>DCT</code>变换，并在频域对变换系数进行量化。对于强边缘，由于高频系数的量化失真，解码后会在边缘周围产生波纹现象，造成此现象的根本原因是高频信息丢失。如图所示，实线中的高频信息丢失后变成了虚线（实线表示原始像素值，虚线表示重构像素值）。可以看出重构像素值在边缘两侧上下波动。</p><p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/%E6%8C%AF%E9%93%83%E6%95%88%E5%BA%942.png" alt="振铃效应"></p></li></ul><hr><h3 id="像素自适应补偿">像素自适应补偿</h3><p>像素值原来是平坦区，因为量化丢弃了部分高频分量，形成了某些像素值得偏移，使得原来相对平坦的像素值关系或多或少地形成局部峰点、谷点或拐点。那么，像素自适应补偿就是人为地对这些飘逸的像素加上一个适当的相反的补偿量，以抵消编码造成的偏移。</p><p><img src="/2021/08/07/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2%E5%92%8CSAO/3596589-2c845f743b4e20a3.png" alt="img"></p><hr><h2 id="参考链接">参考链接</h2><ul><li><p>5.H.265/HEVC—— 环路后处理 <a href="https://www.jianshu.com/p/1de7e26001f4">https://www.jianshu.com/p/1de7e26001f4</a></p></li><li><p>新一代高效视频编码H.265HEVC原理、标准与实现 [万帅，杨付正 编著] 2014年版</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;​	&lt;code&gt;H.265/HEVC&lt;/code&gt; 仍然采用基于块的混合编码框架，方块效应、振铃效应、颜色偏差以及图像模糊等失真效应仍存在。为降低这类失真对视频的影响，&lt;code&gt;H.265/HEVC&lt;/code&gt;采用环路滤波技术，包括去方块滤波（Deblocking Filter）和像素自适应补偿（Sample Adaptive Offset）两个模块。去方块滤波用于降低方块效应，像素自适应补偿用于改善振铃效应。如图所示可以看出，经过滤波的重构像素才能作为后续编码像素参考使用。环路滤波处理后的重建图像更有利于参考，进一步减小后续编码像素的预测残差，可有效地提高视频的主观质量。&lt;/p&gt;</summary>
    
    
    
    <category term="视频" scheme="http://example.com/categories/%E8%A7%86%E9%A2%91/"/>
    
    
    <category term="去块滤波" scheme="http://example.com/tags/%E5%8E%BB%E5%9D%97%E6%BB%A4%E6%B3%A2/"/>
    
    <category term="像素自适应补偿" scheme="http://example.com/tags/%E5%83%8F%E7%B4%A0%E8%87%AA%E9%80%82%E5%BA%94%E8%A1%A5%E5%81%BF/"/>
    
  </entry>
  
  <entry>
    <title>集线器、交换机、路由器</title>
    <link href="http://example.com/2021/08/06/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"/>
    <id>http://example.com/2021/08/06/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/</id>
    <published>2021-08-06T14:14:00.000Z</published>
    <updated>2021-08-06T15:02:50.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="早期网络设备集线器HUB">早期网络设备集线器HUB</h2><h3 id="集线器特点">集线器特点</h3><ul><li>集线器工作于物理层，所有端口同属一个碰撞域和广播域，每个端口仅对数据信号进行放大和转发</li><li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用 <code>CSMA/CD</code> 协议处理总线竞争访问</li><li>由于工作在数据链路层的交换机比集线器性能更高，故集线器已经逐渐被淘汰</li></ul><h3 id="CSMA-CD-和-CSMA-CA-协议"><code>CSMA/CD</code> 和 <code>CSMA/CA</code> 协议</h3><ul><li><code>CSMA/CD</code> 是有线局域网解决总线竞争访问的协议，目前由于交换器的使用这个协议逐渐也被淘汰</li><li><code>CSMA/CA</code> 是无线局域网解决竞争访问的协议，目前仍广泛使用</li></ul><hr><h2 id="交换机SWITCH">交换机SWITCH</h2><h3 id="交换机特点">交换机特点</h3><ul><li><p>交换机工作于数据链路层（也包括物理层），根据MAC地址对帧进行转发</p></li><li><p>交换机的每个接口都是独立的碰撞域，交换机只隔离碰撞域不隔离广播域</p><p><img src="/2021/08/06/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/d058ccbf6c81800aab934511b13533fa828b47bf" alt="交换机"></p></li></ul><h3 id="交换表">交换表</h3><ul><li><p>交换机有一张交换表，表中记录的是<strong>帧的目的MAC地址所对应的接口号</strong>，然后通过该接口转发数据帧</p></li><li><p>刚上电时交换机中的交换表是空的，此时交换机会将从某个接口收到的数据流向除该接口之外的所有接口发送出去（泛洪），随着网络中各主机间的通信，以太网交换机通过<strong>自学习算法</strong>逐渐建立起帧交换表</p></li><li><p>扩展阅读：MAC泛洪攻击和防御 <a href="https://blog.csdn.net/pygain/article/details/52059238">https://blog.csdn.net/pygain/article/details/52059238</a></p></li></ul><h3 id="交换机生成树协议-STP">交换机生成树协议 <code>STP</code></h3><ul><li>为提高网络的可靠性，网络中添加了冗余链路，这些冗余链路可能会出现环路，网络环路会带来以下几个问题：<ul><li>广播风暴：大量消耗网络资源，使网络无法转发其他数据帧</li><li>主机收到重复的广播帧</li><li>交换机的真交换表震荡（漂移）</li></ul></li><li>以太网交换机使用生成树协议<code>STP</code>，可以在增加冗余链路提高网络可靠性的同时又避免网络环路<ul><li>不论交换机之间采用何种物理连接，交换机都能自动计算并构建一个逻辑上没有环路的网络</li><li>最终的生成网络确保可以连通整个网络</li><li>首次接入或者物理网络发生变化，交换机会进行生成树的重新计算</li></ul></li></ul><hr><h2 id="路由器">路由器</h2><h3 id="路由器特点">路由器特点</h3><ul><li><p>路由器工作在网络层，根据IP地址对报文进行转发</p></li><li><p>交换机不能分割广播域，路由可以</p></li><li><p>路由器实现了不同网络之间的数据转发，交换机实现了特定网络内的数据交换</p></li></ul><h3 id="路由表和转发表">路由表和转发表</h3><ul><li>路由表包含目的网络到下一跳的映射</li><li>路由表需要对网络拓扑变化的计算最优化</li><li>转发表是由路由表得出的</li><li>转发表的结构应该使查找过程最优化</li></ul><h3 id="路由选择协议">路由选择协议</h3><ul><li>静态路由选择：人工配置</li><li>动态路由选择：根据路由协议自动获取路由信息<ul><li>内部网关协议<ul><li>路由信息协议<code>RIP</code></li><li>内部网关路由协议<code>IGRP</code></li><li>增强型内部网关路由协议<code>EIGRP</code></li><li>开放式最短路径优先<code>OSPF</code></li><li>中间系统到中间系统<code>IS-IS</code></li></ul></li><li>外部网关协议<ul><li>边界网关协议<code>BGP</code></li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;早期网络设备集线器HUB&quot;&gt;早期网络设备集线器HUB&lt;/h2&gt;
&lt;h3 id=&quot;集线器特点&quot;&gt;集线器特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;集线器工作于物理层，所有端口同属一个碰撞域和广播域，每个端口仅对数据信号进行放大和转发&lt;/li&gt;
&lt;li&gt;使用集线器的以太网在逻辑</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络设备" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/"/>
    
  </entry>
  
  <entry>
    <title>最短路径Dijkstra算法</title>
    <link href="http://example.com/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/</id>
    <published>2021-08-02T11:35:33.000Z</published>
    <updated>2021-08-02T16:18:44.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Dijkstra算法简介">Dijkstra算法简介</h2><p>​Dijkstra算法算是<strong>贪心思想</strong>实现的，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离最短的点作为中转站会不会更近，如果更近了就更新距离，这样把所有的点找遍之后就存下了起点到其他所有点的最短距离。</p><hr><h2 id="算法核心">算法核心</h2><ul><li><p>选择一个节点标记成已经遍历</p><ul><li><p>选择从起点到其他节点路径最短的节点，如图所示起始点0到1、2、3的距离分别为5、2、6，当前不可达的4记作无穷大，则下一个被选择的节点就是2</p><p><img src="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/1627869608-ZNeWka-image.png" alt="图1"></p></li></ul></li><li><p>在遍历过程中更新起始点到其他节点的最短距离</p><ul><li><p>从起始点0到1的距离为5，按照步骤一选取下个节点2后，0-&gt;2-&gt;1距离比0-&gt;1距离要短（这里已经间接说明为什么第一步要选择2的原因了），需要将距离由5更新为3</p><p><img src="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/1627869851-VtwdFS-image.png" alt="图2"></p></li></ul></li><li><p>Dijkstra算法终止条件：遍历完毕所有可达的节点</p><p><img src="/2021/08/02/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84Dijkstra%E7%AE%97%E6%B3%95%E7%90%86%E8%A7%A3/1627869914-XQvKqz-image.png" alt="图3"></p></li></ul><hr><h2 id="算法实现">算法实现</h2><p>LeetCode题目<a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a>，这里我直接用优先队列来实现节点的选择，更能说明问题。</p><pre><code class="language-c++">class Solution {public:    int networkDelayTime(vector&lt;vector&lt;int&gt;&gt;&amp; times, int n, int k)     {        vector&lt;int&gt; dis(n + 1, -1);         dis[k] = 0;        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq; // 元素递增        pq.push(make_pair(0, k)); // first:距离, second:节点编号        while (!pq.empty()) {            pair&lt;int, int&gt; dst = pq.top();            pq.pop(); // 选取优先队列中第一个节点，即从起点到其他节点路径最短的节点            if (dst.first &gt; dis[dst.second]) { // 当前达到dst的权值比记录的还要大，则不可能是最短路径                continue;            }            for (int i = 0; i &lt; times.size(); i++) {                if (times[i][0] != dst.second) {                    continue;                }                // 遍历以dst为起点的路径                int v = times[i][1];                int w = dst.first + times[i][2];                if (dis[v] == -1 || dis[v] &gt; w) {                    dis[v] = w; // 更新距离                    pq.push(make_pair(w, v));                }            }        }        int ans = 0;        for (int i = 1; i &lt;= n; i++) {            if (dis[i] == - 1) {                return -1;            }            ans = max(ans, dis[i]);        }         return ans;    }};</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Dijkstra算法简介&quot;&gt;Dijkstra算法简介&lt;/h2&gt;
&lt;p&gt;​	Dijkstra算法算是&lt;strong&gt;贪心思想&lt;/strong&gt;实现的，首先把起点到所有点的距离存下来找个最短的，然后松弛一次再找出最短的，所谓的松弛操作就是，遍历一遍看通过刚刚找到的距离</summary>
      
    
    
    
    <category term="算法" scheme="http://example.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="Dijkstra" scheme="http://example.com/tags/Dijkstra/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub 搭建个人博客</title>
    <link href="http://example.com/2021/08/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <id>http://example.com/2021/08/01/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</id>
    <published>2021-08-01T15:32:43.000Z</published>
    <updated>2021-08-06T14:42:08.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo-GitHub-搭建个人博客">Hexo + GitHub 搭建个人博客</h2><ul><li><p>安装<code>nodeJs</code>，版本号选择为 <code>v12.14.0</code>，最好选择免安装版本<code>node-v12.14.0-win-x64.zip</code>解压后即可使用</p><p>NodeJs下载地址：<a href="https://nodejs.org/dist/v12.14.0/">https://nodejs.org/dist/v12.14.0/</a>  (注意：免安装版本需要自行添加环境变量)</p></li><li><p>配置<code>npm</code> （<code>nodeJs</code>默认自带<code>npm</code>命令，此步骤可选择，参考链接：<a href="https://www.cnblogs.com/dalyday/p/10664287.html%EF%BC%89">https://www.cnblogs.com/dalyday/p/10664287.html）</a></p><ul><li><p>将<code>npm</code>的默认下载目录从<code>c</code>盘移动到<code>D</code>盘</p><pre><code class="language-shell">npm config set prefix "D:\tool\nodeJs\node_global"npm config set cache "D:\tool\nodeJs\node_cache"</code></pre></li><li><p>配置镜像源，提升速度</p><pre><code class="language-shell">npm config set registry=http://registry.npm.taobao.org</code></pre></li><li><p>查看配置是否成功</p><pre><code class="language-shell">npm config list=====================如下都是回显信息，也可以直接修改C:\Users\xy\.npmrc文件配置===============; cli configsmetrics-registry = "https://registry.npm.taobao.org/"scope = ""user-agent = "npm/6.13.4 node/v12.14.0 win32 x64"; userconfig C:\Users\xy\.npmrccache = "D:\\tool\\nodeJs\\node_cache"prefix = "D:\\tool\\nodeJs\\node_global"registry = "https://registry.npm.taobao.org/"; node bin location = D:\tool\nodeJs\node.exe; cwd = D:\tool; HOME = C:\Users\xy; "npm config ls -l" to show all defaults.</code></pre></li><li><p>由于<code>nodeJs</code>自带的<code>npm</code>不是最新的版本，可以自行升级<code>npm</code>模块</p><pre><code class="language-shell">npm install npm -gnpm -v # 查看npm版本号</code></pre></li><li><p>因为之前修改了<code>npm</code>默认的目录，所以在环境变量<code>PATH</code>中添加<code>D:\tool\nodeJs\node_global</code></p></li></ul></li><li><p>安装 <code>hexo</code></p><pre><code class="language-shell">npm install -g hexo # nodeJs默认自带npm命令</code></pre></li><li><p>选择一个空文件夹作为Blog的根目录，执行初始化，可以自定义下载其他主题</p><pre><code class="language-shell">hexo initgit clone git@github.com:Haojen/hexo-theme-Claudia.git themes/claudia # 下载claudia主题</code></pre></li><li><p>设置<code>NPM</code>淘宝源，安装 <code>CNPM</code></p><pre><code class="language-shell">npm i cnpm -g --registry=http://registry.npm.taobao.org</code></pre></li><li><p>进入<code>Blog</code>根路径安装包</p><pre><code class="language-shell">#必要cnpm install hexo-renderer-pug --savecnpm install hexo-renderer-sass --save cnpm install hexo-generator-search --save cnpm install hexo-deployer-git --save#选择性安装# 如果需要添加订阅功能cnpm install hexo-generator-feed --save # 流程图功能cnpm install hexo-filter-flowchart --save   # Emojicnpm install hexo-filter-github-emojis --save  # 搜索功能cnpm install hexo-generator-search --save   # 数学公式cnpm install hexo-renderer-mathjax --save</code></pre></li><li><p>其他推荐安装包 (可选步骤)</p><ul><li>Hexo中插入<code>mermaid diagrams</code> (<a href="https://blog.csdn.net/Olivia_Vang/article/details/92987859">https://blog.csdn.net/Olivia_Vang/article/details/92987859</a>)</li><li>Hexo中插入本地图片 (<a href="https://blog.csdn.net/xjm850552586/article/details/84101345">https://blog.csdn.net/xjm850552586/article/details/84101345</a>)</li></ul></li><li><p>配置根目录下的 <code>GitHub</code>项目路径</p><pre><code class="language-shell">deploy:  type: git  repository: git@github.com:xy007man/xy007man.github.io.git  branch: master</code></pre></li></ul><hr><h2 id="参考链接">参考链接</h2><ul><li><p><code>Hexo + GitHub</code> 搭建个人博客：<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p></li><li><p><code>Claudia</code> 主题介绍：<a href="https://github.com/Haojen/hexo-theme-Claudia/blob/master/README-CN.md">https://github.com/Haojen/hexo-theme-Claudia/blob/master/README-CN.md</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Hexo-GitHub-搭建个人博客&quot;&gt;Hexo + GitHub 搭建个人博客&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;安装&lt;code&gt;nodeJs&lt;/code&gt;，版本号选择为 &lt;code&gt;v12.14.0&lt;/code&gt;，最好选择免安装版本&lt;code&gt;node-v1</summary>
      
    
    
    
    <category term="其他" scheme="http://example.com/categories/%E5%85%B6%E4%BB%96/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>内核同步机制：mutex锁</title>
    <link href="http://example.com/2021/07/24/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E9%94%81/"/>
    <id>http://example.com/2021/07/24/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E9%94%81/</id>
    <published>2021-07-24T11:08:58.000Z</published>
    <updated>2021-07-28T14:24:51.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mutex锁的使用">Mutex锁的使用</h2><table><thead><tr><th>函数定义</th><th>功能说明</th></tr></thead><tbody><tr><td>mutex_lock(struct mutex *lock)</td><td>加锁，如果不可用，则睡眠（UNINTERRUPTIBLE）</td></tr><tr><td>mutex_lock_interruptible(struct mutex *lock);</td><td>加锁，如果不可用，则睡眠（TASK_INTERRUPTIBLE）</td></tr><tr><td>mutex_unlock(struct mutex *lock)</td><td>解锁</td></tr><tr><td>mutex_trylock(struct mutex *lock)</td><td>试图获取指定的 mutex，或得到返回1，否则返回 0</td></tr><tr><td>mutex_is_locked(struct mutex *lock)</td><td>如果 mutex 被占用返回1，否则返回 0</td></tr></tbody></table><hr><h2 id="Mutex锁和其他锁的区别">Mutex锁和其他锁的区别</h2><ul><li><code>mutex</code> 一种睡眠锁，其行为和 count 为 1 的信号量类似，但是不同于信号量，<code>mutex</code>需要谁拿的锁谁来释放锁</li><li>不同于自旋锁，mutex临界区允许睡眠</li><li>不同于自旋锁，mutex在拿锁时若锁被别人持有，会根据锁的持有者是否正在运行来决定是乐观自旋或是睡眠等待</li></ul><hr><h2 id="Mutex锁的实现">Mutex锁的实现</h2><ul><li><a href="https://blog.csdn.net/zhoutaopower/article/details/86627438">https://blog.csdn.net/zhoutaopower/article/details/86627438</a></li><li><a href="https://zhuanlan.zhihu.com/p/390107537">https://zhuanlan.zhihu.com/p/390107537</a></li></ul><p>​以上两篇文章介绍的比较好，可以参考看一下，总结一下<code>mutex</code>的特点</p><ul><li><code>mutex</code> 由于性能原因并不是绝对公平调度的，允许偷锁的情况，但是为了相对公平引入了<code>handoff</code>机制，让被偷锁的进程在下次一定可以获取锁。</li><li><code>mutex</code> 锁有自旋锁和信号量的特点，即当持有锁的进程处于执行状态时，等待锁的进程会关闭抢占进行自旋；若持有锁的进程处于睡眠状态时，等待锁的进程也会进行休眠，和信号量的表现一致。</li><li>信号量和<code>mutex</code>锁优选<code>mutex</code>。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mutex锁的使用&quot;&gt;Mutex锁的使用&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数定义&lt;/th&gt;
&lt;th&gt;功能说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;mutex_lock(struct mutex *</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="mutex" scheme="http://example.com/tags/mutex/"/>
    
  </entry>
  
  <entry>
    <title>内核同步机制：信号量</title>
    <link href="http://example.com/2021/07/17/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://example.com/2021/07/17/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6_%E4%BF%A1%E5%8F%B7%E9%87%8F/</id>
    <published>2021-07-17T14:22:32.000Z</published>
    <updated>2021-08-01T15:25:56.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信号量的使用">信号量的使用</h2><pre><code class="language-c">struct semaphore {raw_spinlock_tlock;unsigned intcount;struct list_headwait_list;};void sema_init(struct semaphore *sem, int val);void down(struct semaphore *sem);int down_interruptible(struct semaphore *sem); // 在睡眠期间可以被信号打断返回void up(struct semaphore *sem)</code></pre><hr><h2 id="源码分析">源码分析</h2><pre><code class="language-c">void down(struct semaphore *sem){unsigned long flags;raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);if (likely(sem-&gt;count &gt; 0)) // 对应sema_init中的第二个参数val，如果当前大于0，当前进程可以进入临界区执行sem-&gt;count--;else__down(sem); // 否则将将当前进程阻塞住raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);}// down 最终会调用到 __down_commonstatic inline int __sched __down_common(struct semaphore *sem, long state,long timeout){struct semaphore_waiter waiter;list_add_tail(&amp;waiter.list, &amp;sem-&gt;wait_list); // 将当前进程加入等待链表中waiter.task = current; // current 代表当前进程的结构体waiter.up = false;for (;;) {if (signal_pending_state(state, current)) // 如果当前进程有信号处理，则返回-EINTRgoto interrupted;if (unlikely(timeout &lt;= 0))goto timed_out;__set_current_state(state); // 设置当前进程状态(TASK_INTERRUPTIBLE/TASK_UNINTERRUPTIBLE)raw_spin_unlock_irq(&amp;sem-&gt;lock);timeout = schedule_timeout(timeout); // 主动退出调度，进入此函数后进程已经成功阻塞住了，等待被唤醒raw_spin_lock_irq(&amp;sem-&gt;lock); if (waiter.up)return 0;} timed_out:list_del(&amp;waiter.list);return -ETIME; interrupted:list_del(&amp;waiter.list);return -EINTR;}void up(struct semaphore *sem){unsigned long flags;raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);if (likely(list_empty(&amp;sem-&gt;wait_list))) // 当前没有任何进程阻塞在该信号量上sem-&gt;count++;else__up(sem);raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);}static noinline void __sched __up(struct semaphore *sem){struct semaphore_waiter *waiter = list_first_entry(&amp;sem-&gt;wait_list,struct semaphore_waiter, list); // 获取第一个阻塞在此信号量上的进程list_del(&amp;waiter-&gt;list);waiter-&gt;up = true;wake_up_process(waiter-&gt;task); // 唤醒进程}</code></pre><h2 id="总结">总结</h2><p>​可以看到Linux内核中信号量的使用和实现都是十分简洁的。可以看出内核中用一条链表实现了阻塞在信号量上多个进程的公平调度，不过从内核中的实现来看貌似这并不是最优的实现，因为临界区代码往往都比较短小，但是如果进程获取不到信号量就会直接睡眠下去，这可能会造成进程频繁的睡眠唤醒。下一节会分析一下内核中 <code>mutex</code> 的实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信号量的使用&quot;&gt;信号量的使用&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;struct semaphore {
	raw_spinlock_t		lock;
	unsigned int		count;
	struct list_head	</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="信号量" scheme="http://example.com/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>编程银弹</title>
    <link href="http://example.com/2021/07/10/%E7%BC%96%E7%A8%8B%E9%93%B6%E5%BC%B9/"/>
    <id>http://example.com/2021/07/10/%E7%BC%96%E7%A8%8B%E9%93%B6%E5%BC%B9/</id>
    <published>2021-07-10T08:59:52.000Z</published>
    <updated>2021-08-01T15:24:52.146Z</updated>
    
    <content type="html"><![CDATA[<h1>小白</h1><p>记得在大一刚接触编程时，经常陷入语法的陷阱，把大部分精力放在了学习语法上，经常因为知道了语言上的一些奇技淫巧而沾沾自喜。大一实验课设计一个的图书管理系统，代码删删改改，磕磕碰碰最后勉强跑通，感觉费了好多脑细胞。时常听到编程语言只是工具，好的代码是给人看的，好的代码需要好的设计。之后学习了软件工程、接触了23种设计模式，但是仍然懵懵懂懂，经常在想编程到底有没有银弹。</p><span id="more"></span><hr><h1>工作</h1><p>工作之后，部门潇潇洒洒规定了百八十条的编程规范让新员工记住。印象比较深的就是一个函数不要超过50行。其实在刚开始我也没觉的有啥坏处，按照规定来就行了。之后就出现了各种牛鬼蛇神的代码，许多代码明明放在一个函数逻辑比较通顺，为了符合编程规范必须拆分成2个甚至3个函数。</p><hr><h1>思考</h1><p>一个函数超过50行就是烂代码吗？显然不是这样。我也写了几年代码，自己有一点感触。当你要设计一个类或者函数时，第一要<strong>先明确</strong>函数的功能，明确好入参和出参**。新手时常陷入其中细节的逻辑中，缺啥参数返回头在去增加，修改来修改去，最终成型的代码，参数可能有5、6个，临时变量7、8个，函数行数膨胀到2~3百行。第二在写具体逻辑的时候，<strong>如果发现你的脑细胞不够用的，一定要意识到你应该</strong>再封装一个函数了**。你自己写的代码你应该最清楚业务逻辑，但是你自己写的时候都费劲，如果这样的业务代码交给别人去review或者维护那将是一个灾难。一般一个函数代码行数不应该超过一屏半，最好不要超过150行，但是代码行不应该做为判断代码好坏的绝对条件。</p><p>最后回到主题编程有银弹吗？我认为是没有的，不能靠条条框框的编程规范去让程序员写出更好的代码。靠编程规范约束的开发人员不会是一个好的开发人员，他已经被这些条条框框约束住了，缺失了创造力。大家最不愿意做的是啥？就是写设计文档，说白了就是不愿意思考，如果模块的接口定义好了，其实剩下的就是搬砖了。不否定编程规范对新手的积极作用，但是作为一位老鸟应该明白其中的门道。希望有一天我也能像卖油翁那样说一句：“无他，唯手熟尔”。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h1&gt;小白&lt;/h1&gt;
&lt;p&gt;记得在大一刚接触编程时，经常陷入语法的陷阱，把大部分精力放在了学习语法上，经常因为知道了语言上的一些奇技淫巧而沾沾自喜。大一实验课设计一个的图书管理系统，代码删删改改，磕磕碰碰最后勉强跑通，感觉费了好多脑细胞。时常听到编程语言只是工具，好的代码是给人看的，好的代码需要好的设计。之后学习了软件工程、接触了23种设计模式，但是仍然懵懵懂懂，经常在想编程到底有没有银弹。&lt;/p&gt;</summary>
    
    
    
    <category term="编程" scheme="http://example.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS基本原理简析</title>
    <link href="http://example.com/2021/07/03/HTTPS/"/>
    <id>http://example.com/2021/07/03/HTTPS/</id>
    <published>2021-07-03T14:32:50.000Z</published>
    <updated>2021-08-06T14:42:18.222Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础">基础</h2><ul><li><p>对称加密算法</p><p>对称加密算法的特点是加密密钥和解密密钥是同一把密钥K，且加解密速度快，典型的对称加密算法有DES、AES等</p><p><img src="/2021/07/03/HTTPS/548912-20160303105320549-487055351.png" alt="对称加密算法加密流程和解密流程"></p></li><li><p>非对称加密算法</p><p>​非对称加密算法的特点是加密密钥K1和解密密钥K2是不一样的，他们是一对可互为加解密的密钥，一个可以公开，叫公钥；一个自己保留，不能让其他人知道，叫私钥。这样就能比较好的解决信息传递的安全性，相对来说加解密速度较慢，典型的非对称加密算法有RSA、DSA等。</p><p><img src="/2021/07/03/HTTPS/548912-20160303111011190-1826727713.png" alt="非对称加密算法加密流程和解密流程"></p></li></ul><hr><h2 id="非对称加密的两大应用">非对称加密的两大应用</h2><ul><li><p>加密通信：公钥加密，私钥解密</p></li><li><p>数字签名：私钥加密，公钥解密</p><ul><li><p>发送方（甲方）签名过程：使用单向哈希算法对明文生成摘要，用私钥将摘要加密</p><p><img src="/2021/07/03/HTTPS/548912-20160303111013487-1921207550.png" alt="摘要算法及数字签名过程"></p></li><li><p>接收方（乙方）校验过程：接受方把接收到的发送方的明文用单向哈希函数取得摘要值与发送方的公钥解密发送方的数字签名而得到的摘要值进行比较，如果一样说明信息完整，未受篡改，如果不一样说明受到篡改。</p><p><img src="/2021/07/03/HTTPS/548912-20160303111014549-473199446.png" alt="检验数据完整性过程"></p></li></ul></li></ul><hr><h2 id="HTTPS的工作方式">HTTPS的工作方式</h2><p>​<code>HTTPS</code> 实际采用的是混合加密的方式，即通过<strong>非对称加密的方式传递对称加密的密钥，对称加密的方式传递主体数据</strong>，通过<strong>检查证书是不是由可以信赖的机构颁发的，确认证书有效和此证书是此网站的，即检查公钥的合法性</strong>。</p><p><img src="/2021/07/03/HTTPS/548912-20160303111014549-47319944.png" alt="HTTPS工作方式"></p><hr><h2 id="参考链接">参考链接</h2><ul><li><p><a href="https://www.cnblogs.com/gordon0918/p/5237717.html">https://www.cnblogs.com/gordon0918/p/5237717.html</a></p></li><li><p><a href="https://www.cnblogs.com/wang-yaz/p/10604403.html">https://www.cnblogs.com/wang-yaz/p/10604403.html</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;基础&quot;&gt;基础&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对称加密算法&lt;/p&gt;
&lt;p&gt;对称加密算法的特点是加密密钥和解密密钥是同一把密钥K，且加解密速度快，典型的对称加密算法有DES、AES等&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2021/07/03/HTTPS/5489</summary>
      
    
    
    
    <category term="https" scheme="http://example.com/categories/https/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
